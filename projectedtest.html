<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur Pr√©dictif de Pr√©cision Limite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Setup */
        :root {
            --primary-color: #7C3AED; /* Violet */
            --secondary-color: #10B981; /* Green */
            --warning-color: #F59E0B; /* Amber */
            --danger-color: #EF4444; /* Red */
            --bg-color: #f9fafb;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: #1f2937;
        }
        .main-container {
            display: flex;
            min-height: 100vh;
        }
        
        /* Side Panel (Summary/Averages) */
        .side-panel {
            width: 100%;
            max-width: 380px; 
            background-color: white;
            padding: 1.5rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            border-radius: 0.75rem;
            margin: 1rem;
            height: fit-content;
        }
        @media (max-width: 1024px) {
            .main-container { flex-direction: column; }
            .side-panel { max-width: 100%; }
        }

        /* Content Area (Tabs/Tables) */
        .content-area {
            flex-grow: 1;
            padding: 1rem;
        }
        .tab-btn {
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            border-radius: 0.375rem 0.375rem 0 0;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #eef2ff; /* Violet-50 */
            color: #4c1d95; /* Violet-900 */
            margin-right: 0.25rem;
        }
        .tab-btn.active {
            background-color: white;
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
            box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.05);
        }
        .tab-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0 0.75rem 0.75rem 0.75rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }
        .tab-content:not(.active) { display: none; }

        /* Subject Tables (Simplified for Analysis) */
        .subject-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 1.5rem; 
        }
        .subject-table thead th {
            padding: 0.75rem;
            text-align: left;
            background-color: var(--primary-color);
            color: white;
            font-weight: 700;
        }
        .subject-table thead tr:first-child th {
            font-size: 1.125rem;
            text-align: center;
        }
        .subject-table tbody tr:nth-child(even) { background-color: #f3f4f6; }
        .subject-table td {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .grade-percentage {
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Analysis Specifics */
        .subject-analysis {
            background-color: #f5f3ff; /* Purple-50 */
            border: 1px solid #e9d5ff; /* Purple-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: -1rem; 
            margin-bottom: 1.5rem;
        }
        .analysis-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }
        .badge-green { background-color: #D1FAE5; color: #065F46; } 
        .badge-yellow { background-color: #FEF3C7; color: #92400E; } 
        .badge-red { background-color: #FEE2E2; color: #991B1B; } 
        .badge-violet { background-color: #E9D5FF; color: #5B21B6; }

        /* Prediction Cards */
        .prediction-card {
            background-color: #f7f7f7;
            padding: 1rem;
            border-radius: 0.5rem;
            border-left: 4px solid;
            margin-bottom: 1rem;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .card-green { border-left-color: var(--secondary-color); }
        .card-violet { border-left-color: var(--primary-color); }
        .card-red { border-left-color: var(--danger-color); }
        .card-score {
            font-size: 1.875rem; 
            font-weight: 800;
            margin-top: 0.25rem;
        }

        /* Probability Table */
        .probability-table th, .probability-table td {
            padding: 0.5rem;
            text-align: center;
            border: 1px solid #e5e7eb;
        }
        .prob-high { background-color: #D1FAE5; color: #065F46; font-weight: 700;}
        .prob-medium { background-color: #FEF3C7; color: #92400E; }
        .prob-low { background-color: #FEE2E2; color: #991B1B; }
        
        /* Modal - Simplified */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s ease-out;
            opacity: 0;
            pointer-events: none;
        }
        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }

    </style>
</head>
<body>

    <div class="main-container">

        <!-- Sidebar - R√©sum√© des notes -->
        <div class="side-panel lg:sticky lg:top-4">
            <h2 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2">Moteur d'Analyse de Performance</h2>

            <div class="bg-indigo-50 p-4 rounded-lg mb-4 border-l-4 border-indigo-600">
                <p class="text-sm font-medium text-gray-700">Moyenne G√©n√©rale Pond√©r√©e (Actuelle)</p>
                <strong id="moyenne-generale" class="text-4xl font-extrabold text-gray-900">--</strong>
            </div>
            
            <h3 class="text-lg font-semibold mt-6 mb-3 text-gray-800 border-t pt-3">Indices de Risque Global</h3>
            <div id="deep-analysis-scorecard" class="space-y-3 mb-6">
                <!-- Consistency/Effort -->
                <div class="score-card score-high" id="consistency-score">
                    <span class="score-icon text-gray-600">üéØ</span>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Indice de Consistance/Volatilit√© (100 = Parfait)</p>
                        <strong class="text-xl text-gray-800">--</strong>
                    </div>
                </div>
                <!-- Burnout -->
                <div class="score-card score-low" id="burnout-risk-score">
                    <span class="score-icon text-red-600">üî•</span>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Score de Risque de Burnout (100 = Risque Maximal)</p>
                        <strong class="text-xl text-red-600">--</strong>
                    </div>
                </div>
            </div>

            <h3 class="text-lg font-semibold mt-4 mb-2 text-gray-700 border-t pt-3">Moyennes par Mati√®re (<span id="active-etape-name">1</span>)</h3>
            <ul id="subject-averages-list" class="space-y-2 text-base">
                <!-- Subject Averages will be rendered here -->
            </ul>

            <h3 class="text-lg font-semibold mt-4 mb-2 text-gray-700 border-t pt-3">Param√®tres Actuels</h3>
            <div class="space-y-3 mb-6 text-sm">
                <div>
                    <label for="niveau-secondaire" class="block text-sm font-medium text-gray-700">Niveau Secondaire</label>
                    <select id="niveau-secondaire" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm py-2 px-3 focus:ring-primary-500 focus:border-primary-500">
                        <option value="">S√©lectionner</option>
                        <option value="sec4">Secondaire 4</option>
                        <option value="sec5">Secondaire 5</option>
                    </select>
                </div>
                <div>
                    <label for="unites-mode" class="block text-sm font-medium text-gray-700">Mode Unit√©s (Pond√©ration)</label>
                    <div class="flex space-x-2">
                        <select id="unites-mode" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm py-2 px-3 focus:ring-primary-500 focus:border-primary-500">
                            <option value="defaut">D√©faut (Officiel)</option>
                            <option value="sans">Sans Unit√©s (Moy. Simple)</option>
                            <option value="perso">Personnalis√©</option>
                        </select>
                        <button id="unites-btn" class="bg-gray-200 text-gray-600 rounded-md px-3 hover:bg-gray-300 transition duration-150 text-sm">√âditer</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content - Tabs & Tables -->
        <div class="content-area">
            <h1 class="text-3xl font-bold mb-4 text-gray-800">D√©tails de Performance & Pr√©dictions</h1>

            <!-- Tabs -->
            <div class="flex border-b border-gray-200 mb-4">
                <button class="tab-btn active" data-tab="etape1">√âtape 1 - Analyse</button>
                <button class="tab-btn" data-tab="etape2">√âtape 2 - Analyse</button>
                <button class="tab-btn" data-tab="etape3">√âtape 3 - Projection</button>
                <button class="tab-btn" data-tab="simulation">Monte Carlo & Probabilit√©s</button>
            </div>

            <!-- Tab Contents -->
            <div id="tab-contents">
                <div id="etape1" class="tab-content active">
                    <!-- Data for Etape 1 will be rendered here -->
                </div>
                <div id="etape2" class="tab-content">
                    <!-- Data for Etape 2 will be rendered here -->
                </div>
                <div id="etape3" class="tab-content">
                    <!-- Data for Etape 3 will be rendered here -->
                </div>

                <!-- Monte Carlo Simulation Tab -->
                <div id="simulation" class="tab-content">
                    <h2 class="text-2xl font-bold mb-4 text-primary-color">Analyse Pr√©dictive Monte Carlo Avanc√©e</h2>
                    <p class="text-gray-600 mb-6 border-b pb-4">
                        *L'algorithme a ex√©cut√© <strong class="text-primary-color">10,000 sc√©narios probabilistes stochastiques par mati√®re</strong>, ajust√©s par la volatilit√© individuelle (√©cart-type) et le niveau d'effort/consistance. Pr√©cision limite absolue.*
                    </p>

                    <!-- Global Predictions -->
                    <h3 class="text-xl font-semibold mb-3 mt-4 text-gray-700">Pr√©dictions de Moyenne Finale Globale</h3>
                    <div id="global-predictions" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Predictions will be rendered here -->
                    </div>

                    <!-- Probability Analysis -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Analyse de Chemin : Moyenne Requise √† l'√âtape 3</h3>
                    <p class="text-sm text-gray-600 mb-4">Moyenne exacte que vous devez obtenir √† l'√âtape 3 pour atteindre chaque objectif global.</p>
                    <table class="probability-table w-full rounded-lg overflow-hidden">
                        <thead>
                            <tr class="bg-gray-100">
                                <th>Objectif Global (%)</th>
                                <th>Moyenne Requise E3 (%)</th>
                                <th>Probabilit√© (%)</th>
                                <th>Analyse du Risque</th>
                            </tr>
                        </thead>
                        <tbody id="probability-table-body">
                            <!-- Probabilities will be rendered here -->
                        </tbody>
                    </table>

                     <!-- Subject Predictions (Detailed) -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Pr√©dictions Tendancielles D√©tail√©es par Mati√®re</h3>
                    <p class="text-sm text-gray-600 mb-4">Pr√©diction de note finale (E1+E2+E3) si l'effort et la volatilit√© actuels se maintiennent (Tendance Stochastique).</p>
                    <div id="subject-predictions-list" class="space-y-3">
                        <!-- Subject predictions will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Unit Customization -->
    <div id="unites-modal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4">Unit√©s par Mati√®re</h3>
            <p class="text-sm text-gray-500 mb-4">Ajustez les unit√©s pour chaque mati√®re si le mode 'Personnalis√©' est s√©lectionn√©.</p>
            <div id="unites-list" class="max-h-80 overflow-y-auto border p-3 rounded-md space-y-2">
                <!-- Units will be populated here -->
            </div>
            <div class="mt-6 flex justify-end">
                <button id="close-unites-modal" class="bg-primary-color text-white px-4 py-2 rounded-md hover:bg-violet-700 transition">Fermer & Appliquer</button>
            </div>
        </div>
    </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {

    // --- CONSTANTS AND STATE ---
    const gradeMap = { 'A+': 100, 'A': 95, 'A-': 90, 'B+': 85, 'B': 80, 'B-': 75, 'C+': 70, 'C': 65, 'C-': 60, 'D+': 55, 'D': 50, 'E': 45 };
    const defaultUnits = {
        sec4: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'FRA': 6, 'ELA': 4, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 6, 'ST': 4, 'STE': 4, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'ENT': 2, 'INF': 2, 'PSY': 2 },
        sec5: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'CAT': 4, 'FRA': 6, 'ELA': 6, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 4, 'MED': 4, 'PSY': 4, 'ENT': 4, 'FIN': 4, 'CHI': 4, 'PHY': 4, 'MON': 2, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'FIN': 2 }
    };
    const subjectList = { 'ART': "Arts Plastiques", 'MUS': "Musique", 'DRM': "Art Dramatique", 'CAT': "Conception et Application Technologique", 'FRA': "Fran√ßais", 'ELA': "English Language Arts", 'EESL': "Anglais enrichi", 'ESL': "Anglais langue seconde", 'SN': "Math SN", 'CST': "Math CST", 'ST': "Science et Technologie", 'STE': "Science et Tech. Env.", 'HQC': "Histoire", 'CCQ': "Culture et Citoyennet√©", 'EPS': "√âducation Physique", 'CHI': "Chimie", 'PHY': "Physique", 'MON': "Monde Contemporain", 'MED': "M√©dia", 'ENT': "Entrepreneuriat", 'INF': "Informatique", 'PSY': "Psychologie", 'FIN': "√âducation Financi√®re" };
    
    const TERM_WEIGHTS = { etape1: 0.20, etape2: 0.20, etape3: 0.60 };

    let mbsData = {};
    let activeTab = 'etape1';
    let cachedAnalysis = null;
    const NUM_MONTE_CARLO_RUNS = 10000; // Pushing the limit of calculation

    // --- INITIALIZATION ---
    function init() {
        mbsData = JSON.parse(localStorage.getItem('mbsData')) || {};

        if (!mbsData.valid || !mbsData.nom) {
            const mainContainer = document.querySelector('.main-container');
            if (mainContainer) {
                mainContainer.innerHTML = `<p style="text-align:center; width:100%; padding: 4rem;">Donn√©es non charg√©es. Veuillez vous assurer que les donn√©es sont enregistr√©es sous 'mbsData' dans le Local Storage.</p>`;
            }
            return;
        }

        loadSettings();
        calculateAndCacheAnalysis();
        renderAll();
        setupEventListeners();
    }

    // --- DATA & SETTINGS MANAGEMENT ---
    function loadSettings() {
        const settings = mbsData.settings || {};
        document.getElementById('niveau-secondaire').value = settings.niveau || '';
        document.getElementById('unites-mode').value = settings.unitesMode || 'defaut';
    }

    function saveSettings() {
        mbsData.settings = mbsData.settings || {};
        mbsData.settings.niveau = document.getElementById('niveau-secondaire').value;
        mbsData.settings.unitesMode = document.getElementById('unites-mode').value;
        mbsData.settings.customUnites = mbsData.settings.customUnites || {};
        
        localStorage.setItem('mbsData', JSON.stringify(mbsData));
        calculateAndCacheAnalysis();
        renderAll();
    }
    
    function saveCustomUnits() {
        const unitesModeEl = document.getElementById('unites-mode');
        if (unitesModeEl.value !== 'perso') return;

        let customUnites = {};
        document.querySelectorAll('.unite-item input').forEach(input => {
            customUnites[input.dataset.code] = parseFloat(input.value) || 1;
        });
        
        mbsData.settings = mbsData.settings || {};
        mbsData.settings.customUnites = customUnites;
        saveSettings();
    }

    // --- RENDERING FUNCTIONS ---
    function renderAll() {
        renderTermTables();
        const analysis = cachedAnalysis;
        renderSidePanel(analysis);
        renderDeepAnalysis(analysis);
        renderMonteCarlo(analysis);
    }

    function renderTermTables() {
        ['etape1', 'etape2', 'etape3'].forEach(key => {
            const container = document.getElementById(key);
            if (container) renderTermData(mbsData[key], container, key, cachedAnalysis);
        });
    }

    function renderTermData(termData, container, etapeKey, analysis) {
        if (!container) return; 

        if (!termData || termData.length === 0) {
            container.innerHTML = '<p class="no-data text-gray-500">Aucune donn√©e de base pour cette √©tape.</p>';
            return;
        }
        container.innerHTML = '';
        termData.forEach((subject, subjectIndex) => {
            const codePrefix = subject.code.substring(0, 3);
            const subjStats = analysis.subjectStats[codePrefix]?.[etapeKey];

            // 1. Render Subject Table (Simplified)
            container.appendChild(renderSubjectTable(subject, etapeKey, subjectIndex, subjStats));
            
            // 2. Render Subject Analysis
            container.appendChild(renderSubjectAnalysis(codePrefix, etapeKey, analysis));
        });
    }

    function renderSubjectTable(subject, etapeKey, subjectIndex, subjStats) {
        const table = document.createElement('table');
        table.className = 'subject-table';
        const codePrefix = subject.code.substring(0, 3);
        const subjectName = subjectList[codePrefix] || subject.name;
        
        table.innerHTML = `
            <thead>
                <tr><th colspan="3">${codePrefix} - ${subjectName}</th></tr>
                <tr>
                    <th>Comp√©tence</th>
                    <th>Moyenne Actuelle</th>
                    <th>Effort Interne (Consistance/100)</th>
                </tr>
            </thead>
            <tbody></tbody>`;
        const tbody = table.querySelector('tbody');

        subject.competencies.forEach((comp, compIndex) => {
            const compAvg = subjStats?.competencyAverages?.[compIndex]?.avg;
            const compConsistency = subjStats?.competencyAverages?.[compIndex]?.consistency;

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${comp.name}</td>
                <td>${compAvg !== null ? `<span class="grade-percentage">${compAvg.toFixed(2)}%</span>` : '<span class="no-data">N/D</span>'}</td>
                <td>
                    ${compConsistency !== null ? `
                        <span class="analysis-badge ${getConsistencyBadgeClass(compConsistency)}">${compConsistency.toFixed(0)}/100</span>
                    ` : '<span class="no-data">-</span>'}
                </td>
            `;
            if (tbody) tbody.appendChild(row);
        });
        return table;
    }

    function getConsistencyBadgeClass(score) {
        if (score >= 90) return 'badge-green';
        if (score >= 70) return 'badge-yellow';
        return 'badge-red';
    }

    function renderSubjectAnalysis(subjectCode, etapeKey, analysis) {
        const analysisDiv = document.createElement('div');
        analysisDiv.className = 'subject-analysis';
        
        const subjAvg = analysis.subjectAverages[etapeKey]?.[subjectCode]?.average;
        const subjStats = analysis.subjectStats[subjectCode]?.[etapeKey];
        const subjOverallStats = analysis.subjectOverallStats[subjectCode];
        const trend = analysis.subjectTrends?.[subjectCode];

        if (subjAvg === null || subjAvg === undefined) {
            analysisDiv.innerHTML = `<p class="text-sm text-gray-500">Aucune donn√©e pour l'analyse de ${subjectList[subjectCode]}.</p>`;
            return analysisDiv;
        }

        // 1. Overall Consistency Badge
        let overallConsistency = subjStats?.overallConsistency || 0;
        let consistencyBadge = { label: 'Volatilit√© Max', class: 'badge-red', icon: '‚ùå' };
        if (overallConsistency >= 90) consistencyBadge = { label: 'Tr√®s Stable', class: 'badge-green', icon: '‚úÖ' };
        else if (overallConsistency >= 70) consistencyBadge = { label: 'Stable', class: 'badge-yellow', icon: '‚ö†Ô∏è' };
        
        // 2. Volatility (StdDev) Badge
        const stdDev = subjOverallStats?.stdDev || 0;
        let volatilityBadge = { label: `Volatilit√© : ${stdDev.toFixed(1)}%`, class: 'badge-violet', icon: '‚ôº' };
        if (stdDev > 10) volatilityBadge.class = 'badge-red';
        else if (stdDev > 5) volatilityBadge.class = 'badge-yellow';
        else volatilityBadge.class = 'badge-green';
        
        // 3. Trend Badge (Only for Etape 2 & 3)
        let trendBadge = { label: 'N/A', class: 'badge-violet', icon: ' ' };
        let trendDescription = 'Analyse de tendance disponible apr√®s l\'√âtape 2.';

        if (trend && etapeKey !== 'etape1') {
            const diff = trend.diff;
            if (diff > 2) {
                trendBadge = { label: `Forte Hausse (+${diff.toFixed(1)}%)`, class: 'badge-green', icon: '‚¨ÜÔ∏è' };
                trendDescription = 'La note est en nette am√©lioration. L\'effort porte ses fruits.';
            } else if (diff < -2) {
                trendBadge = { label: `Baisse Importante (${diff.toFixed(1)}%)`, class: 'badge-red', icon: '‚¨áÔ∏è' };
                trendDescription = 'Baisse significative. Urgent d\'analyser les causes et la r√©partition de l\'effort.';
            } else {
                trendBadge = { label: 'Stable', class: 'badge-yellow', icon: '‚ÜîÔ∏è' };
                trendDescription = 'Tendance stable. Maintenez l\'effort.';
            }
        }

        analysisDiv.innerHTML = `
            <div class="flex items-center mb-2 flex-wrap">
                <span class="text-lg font-semibold text-gray-800 mr-4">Diagnostic D√©taill√© - ${subjectList[subjectCode]}</span>
                <span class="analysis-badge ${consistencyBadge.class}">${consistencyBadge.icon} Consistance E/C: ${overallConsistency.toFixed(0)}/100</span>
                <span class="analysis-badge ${volatilityBadge.class}">${volatilityBadge.icon} ${volatilityBadge.label}</span>
                ${etapeKey !== 'etape1' ? `<span class="analysis-badge ${trendBadge.class} mt-2 md:mt-0">${trendBadge.icon} Tendance: ${trendBadge.label}</span>` : ''}
            </div>
            <p class="text-sm text-gray-700 mt-2">Moyenne de l'√©tape : <strong>${subjAvg.toFixed(2)}%</strong>. Volatilit√© (√©cart-type) des notes individuelles : **${stdDev.toFixed(1)}%**.</p>
        `;

        return analysisDiv;
    }

    function renderSidePanel(analysis) {
        const formatAvg = (avg) => avg !== null ? `<span class="grade-percentage">${avg.toFixed(2)}%</span>` : '--';

        document.getElementById('moyenne-generale').innerHTML = formatAvg(analysis.globalAverage);
        
        document.getElementById('active-etape-name').textContent = activeTab.replace('etape', '');
        
        const subjectListEl = document.getElementById('subject-averages-list');
        subjectListEl.innerHTML = '';
        const activeTermSubjects = analysis.subjectAverages[activeTab];
        if (activeTermSubjects && Object.keys(activeTermSubjects).length > 0) {
            Object.entries(activeTermSubjects).forEach(([code, subj]) => {
                const li = document.createElement('li');
                li.className = 'flex justify-between';
                li.innerHTML = `<span>${subj.name}</span><strong>${formatAvg(subj.average)}</strong>`;
                subjectListEl.appendChild(li);
            });
        } else {
            subjectListEl.innerHTML = '<li class="no-data text-gray-500">Aucune mati√®re pour cette √©tape</li>';
        }
    }

    function renderDeepAnalysis(analysis) {
        const { globalConsistencyScore, burnoutRiskScore } = analysis;
        
        // 1. Consistency
        const consistencyEl = document.getElementById('consistency-score');
        if (consistencyEl) {
            consistencyEl.className = 'score-card';
            consistencyEl.querySelector('strong').textContent = globalConsistencyScore.toFixed(0) + ' / 100';
            if (globalConsistencyScore < 70) consistencyEl.classList.add('card-red');
            else if (globalConsistencyScore < 90) consistencyEl.classList.add('card-violet');
            else consistencyEl.classList.add('card-green');
        }

        // 2. Burnout Risk (High score = high risk)
        const riskEl = document.getElementById('burnout-risk-score');
        if (riskEl) {
            riskEl.className = 'score-card';
            riskEl.querySelector('strong').textContent = burnoutRiskScore.toFixed(0) + ' / 100';
            if (burnoutRiskScore > 70) riskEl.classList.add('card-red');
            else if (burnoutRiskScore > 40) riskEl.classList.add('card-yellow');
            else riskEl.classList.add('card-green');
            
            riskEl.querySelector('p').textContent = `Score de Risque de Burnout (100 = Risque Maximal) - ${getBurnoutLabel(burnoutRiskScore)}`;
        }
    }

    function getBurnoutLabel(score) {
        if (score > 85) return 'Urgence: Surcharge et Volatilit√© Extr√™mes.';
        if (score > 70) return 'Tr√®s √âlev√©: Risque majeur de fatigue et notes impr√©visibles.';
        if (score > 50) return '√âlev√©: Forte charge ou Consistance √† surveiller.';
        if (score > 30) return 'Mod√©r√©: Charge g√©rable mais l√©g√®re baisse de performance.';
        return 'Faible: Stabilit√© et Effort bien g√©r√©s.';
    }

    function renderMonteCarlo(analysis) {
        const { globalAverage, globalStdDev, predictions } = analysis;
        const globalPredEl = document.getElementById('global-predictions');
        const probTableEl = document.getElementById('probability-table-body');
        const subjPredEl = document.getElementById('subject-predictions-list');
        
        if (!globalPredEl || !probTableEl || !subjPredEl) return;

        // --- 1. Global Predictions ---
        const predictionScenarios = [
            { name: "1. Max Th√©orique (100% dans tout)", key: 'theoreticalMax', desc: 'Si toutes les mati√®res restantes obtiennent 100% √† l\'√âtape 3.', class: 'card-green' },
            { name: "2. Optimiste Ponder√©", key: 'optimistic', desc: 'Pr√©diction en tenant compte d\'une am√©lioration de 1.5 √©cart-type par mati√®re.', class: 'card-green' },
            { name: "3. Tendanciel Stochastique (Plus Probable)", key: 'trend', desc: 'R√©sultat moyen des 10,000 simulations Monte Carlo (plus r√©aliste).', class: 'card-violet' },
            { name: "4. Pessimiste Ponder√©", key: 'pessimistic', desc: 'Pr√©diction en tenant compte d\'une chute de 1.0 √©cart-type par mati√®re.', class: 'card-yellow' },
            { name: "5. Seuil de R√©ussite (Min 60%)", key: 'minPass', desc: 'Moyenne finale si l\'√âtape 3 atteint la note minimale pour assurer 60% global.', class: 'card-red' },
        ];
        
        globalPredEl.innerHTML = predictionScenarios.map(scenario => {
            const value = predictions.global?.[scenario.key];
            const display = value !== null ? (value > 100 ? '>100%' : `${value.toFixed(2)}%`) : '--';
            const colorClass = scenario.key === 'minPass' && value > 80 ? 'card-red' : scenario.class;
            
            return `
                <div class="prediction-card ${colorClass}">
                    <p class="font-bold text-gray-700">${scenario.name}</p>
                    <p class="text-sm text-gray-500">${scenario.desc}</p>
                    <div class="card-score text-gray-900">${display}</div>
                </div>
            `;
        }).join('');


        // --- 2. Probability Analysis & Required Average E3 ---
        const targets = [95, 92, 90, 88, 85, 80, 75, 70, 60];
        probTableEl.innerHTML = targets.map(target => {
            const { requiredAvg, prob } = predictions.probabilityAnalysis[target];
            
            let probClass = 'prob-low';
            let effort = 'Effort Extr√™me';

            if (prob >= 90) { probClass = 'prob-high'; effort = 'Maintenir Consistance'; }
            else if (prob >= 70) { probClass = 'prob-medium'; effort = 'Effort Mod√©r√©/Cibl√©'; }
            else if (prob >= 40) { probClass = 'prob-low'; effort = 'Effort Int√©gral'; }

            let requiredAvgDisplay = requiredAvg !== null ? (requiredAvg > 100 ? 'IMPOSSIBLE (100+)' : `${requiredAvg.toFixed(2)}%`) : '--';
            if (requiredAvg !== null && requiredAvg < 60) requiredAvgDisplay = `<span class="text-green-600">FAIBLE (${requiredAvg.toFixed(2)}%)</span>`;
            
            return `
                <tr class="${probClass}">
                    <td>${target}%</td>
                    <td>${requiredAvgDisplay}</td>
                    <td>${prob.toFixed(0)}%</td>
                    <td>${effort}</td>
                </tr>
            `;
        }).join('');
        
        // --- 3. Subject Predictions ---
        subjPredEl.innerHTML = Object.entries(predictions.subjects).map(([code, subjPred]) => {
            const prediction = subjPred.trend;
            
            const cardClass = prediction >= 90 ? 'card-green' : (prediction >= 80 ? 'card-violet' : 'card-red');

            return `
                <div class="prediction-card ${cardClass}">
                    <div class="flex justify-between items-center">
                        <p class="font-bold text-lg text-gray-800">${subjectList[code] || code}</p>
                        <div class="text-sm text-gray-500">
                            Ecart-type: ${subjPred.stdDev.toFixed(1)}% | Consistance E/C: ${subjPred.consistency.toFixed(0)}/100
                        </div>
                    </div>
                    <p class="text-sm text-gray-500">Pr√©diction Tendancielle Stochastique Finale (R√©sultat MC)</p>
                    <div class="card-score text-gray-900">${prediction !== null ? prediction.toFixed(2) + '%' : '--'}</div>
                </div>
            `;
        }).join('');
    }

    // --- CALCULATION LOGIC ---
    function getNumericGrade(result) {
        if (!result) return null;
        const trimmed = result.trim();
        if (gradeMap[trimmed]) return gradeMap[trimmed];
        
        const percentageMatch = trimmed.match(/(\d+[,.]?\d*)\s*%/);
        if (percentageMatch) return parseFloat(percentageMatch[1].replace(',', '.'));

        const scoreMatch = trimmed.match(/(\d+[,.]?\d*)\s*\/\s*(\d+[,.]?\d*)/);
        if (scoreMatch) {
            const score = parseFloat(scoreMatch[1].replace(',', '.'));
            const max = parseFloat(scoreMatch[2].replace(',', '.'));
            return (max > 0) ? (score / max) * 100 : null;
        }
        return null;
    }
    
    function getUnits() {
        const { niveau, unitesMode, customUnites } = mbsData.settings || {};
        if (unitesMode === 'sans') return new Proxy({}, { get: () => 1 });
        if (unitesMode === 'perso') return customUnites || {};
        return (niveau && defaultUnits[niveau]) ? defaultUnits[niveau] : {};
    }
    
    function calculateAndCacheAnalysis() {
        cachedAnalysis = calculateAllAnalysis();
    }

    function calculateSubjectAverageAndStats(subject, etapeKey, subjectIndex) {
        let totalWeightedGrade = 0;
        let totalCompetencyWeight = 0;
        let allGrades = [];
        let competencyAverages = [];

        subject.competencies.forEach((comp, compIndex) => {
            const compWeightMatch = comp.name.match(/\((\d+)%\)/);
            const compWeight = compWeightMatch ? parseFloat(compWeightMatch[1]) : 0;
            if (compWeight === 0) return;

            let compGrades = [];
            let totalAssignmentGrade = 0;
            let totalAssignmentWeight = 0;

            comp.assignments.forEach(assign => {
                const grade = getNumericGrade(assign.result);
                let weight = parseFloat(assign.pond || 0);

                if (grade !== null && !isNaN(grade) && !isNaN(weight) && weight > 0) {
                    allGrades.push(grade);
                    compGrades.push(grade);
                    totalAssignmentGrade += grade * weight;
                    totalAssignmentWeight += weight;
                }
            });

            let compAvg = null;
            let compConsistency = null;
            if (totalAssignmentWeight > 0) {
                compAvg = totalAssignmentGrade / totalAssignmentWeight;
                totalWeightedGrade += compAvg * (compWeight / 100);
                totalCompetencyWeight += (compWeight / 100);
            }
            if (compGrades.length >= 2) {
                compConsistency = calculateConsistencyScore(compGrades);
            }

            competencyAverages.push({ avg: compAvg, consistency: compConsistency, compWeight });
        });

        const subjectAverage = totalCompetencyWeight > 0 ? (totalWeightedGrade / totalCompetencyWeight) : null;
        const overallConsistency = allGrades.length >= 2 ? calculateConsistencyScore(allGrades) : 100;
        const stdDev = allGrades.length >= 2 ? calculateStdDev(allGrades) : 0;
        
        return { subjectAverage, allGrades, overallConsistency, stdDev, competencyAverages };
    }

    function calculateConsistencyScore(grades) {
        const stdDev = calculateStdDev(grades);
        return Math.max(0, 100 - (stdDev * 2));
    }
    
    function calculateStdDev(grades) {
        if (grades.length < 2) return 0;
        const mean = grades.reduce((a, b) => a + b) / grades.length;
        const variance = grades.reduce((sum, grade) => sum + Math.pow(grade - mean, 2), 0) / grades.length;
        return Math.sqrt(variance);
    }
    
    function calculateAllAnalysis() {
        const units = getUnits();
        const niveau = mbsData.settings?.niveau;
        let allTermAverages = { etape1: null, etape2: null, etape3: null };
        let allSubjectAverages = {};
        let allSubjectStats = {}; // { code: { etape: { stats } } }
        let allSubjectOverallStats = {}; // { code: { allGrades, stdDev, overallConsistency } }
        let allGradesGlobal = [];

        // 1. Calculate Averages and Stats per Subject/Etape
        ['etape1', 'etape2', 'etape3'].forEach(etape => {
            if (!mbsData[etape]) return;
            let termWeightedSum = 0;
            let termUnitSum = 0;
            allSubjectAverages[etape] = {};
            allSubjectStats[etape] = {};

            mbsData[etape].forEach((subject, subjectIndex) => {
                const codePrefix = subject.code.substring(0, 3);
                
                const { subjectAverage, allGrades, overallConsistency, stdDev, competencyAverages } = 
                    calculateSubjectAverageAndStats(subject, etape, subjectIndex);

                allGradesGlobal.push(...allGrades);
                
                // Store subject average
                allSubjectAverages[etape][codePrefix] = { name: subjectList[codePrefix] || subject.name, average: subjectAverage };
                
                // Store subject stats
                allSubjectStats[codePrefix] = allSubjectStats[codePrefix] || {};
                allSubjectStats[codePrefix][etape] = { overallConsistency, stdDev, competencyAverages, allGrades };
            });
        });

        // 1.5 Calculate Overall Subject Stats (across all terms)
        Object.keys(allSubjectStats).forEach(code => {
            let grades = [];
            let consistencies = [];
            ['etape1', 'etape2'].forEach(etape => {
                if (allSubjectStats[code][etape]) {
                    grades.push(...allSubjectStats[code][etape].allGrades);
                    consistencies.push(allSubjectStats[code][etape].overallConsistency);
                }
            });
            const overallStdDev = calculateStdDev(grades);
            const overallConsistency = consistencies.length > 0 ? consistencies.reduce((a, b) => a + b) / consistencies.length : 100;
            
            allSubjectOverallStats[code] = { allGrades: grades, stdDev: overallStdDev, overallConsistency };
        });

        // 2. Calculate Term Averages and Global Averages
        let globalWeightedSum = 0;
        let totalKnownWeight = 0;
        
        ['etape1', 'etape2', 'etape3'].forEach(etape => {
            let termWeightedSum = 0;
            let termUnitSum = 0;
            
            Object.keys(allSubjectAverages[etape] || {}).forEach(codePrefix => {
                const avg = allSubjectAverages[etape][codePrefix].average;
                if (avg !== null && niveau) {
                    const unit = units[codePrefix] || 2;
                    termWeightedSum += avg * unit;
                    termUnitSum += unit;
                }
            });
            
            allTermAverages[etape] = termUnitSum > 0 ? termWeightedSum / termUnitSum : null;

            if (allTermAverages[etape] !== null) {
                globalWeightedSum += allTermAverages[etape] * TERM_WEIGHTS[etape];
                totalKnownWeight += TERM_WEIGHTS[etape];
            }
        });

        const globalAverage = totalKnownWeight > 0 ? globalWeightedSum / totalKnownWeight : null;

        // 3. Calculate Global Statistics
        let globalStdDev = allGradesGlobal.length >= 2 ? calculateStdDev(allGradesGlobal) : 0;
        let globalConsistencyScore = allGradesGlobal.length >= 2 ? calculateConsistencyScore(allGradesGlobal) : 100;


        // 4. Subject Trends
        let subjectTrends = {};
        Object.keys(allSubjectStats).forEach(code => {
            const avg1 = allSubjectAverages.etape1?.[code]?.average || null;
            const avg2 = allSubjectAverages.etape2?.[code]?.average || null;
            if (avg1 !== null && avg2 !== null) {
                subjectTrends[code] = { diff: avg2 - avg1 }; 
            }
        });
        
        // 5. Burnout Risk (High score = high risk)
        let burnoutRiskScore = calculateBurnoutRisk(niveau, allTermAverages, globalStdDev, allSubjectOverallStats, units);

        // 6. Monte Carlo Predictions
        const predictions = runMonteCarloSimulation(globalAverage, allTermAverages, allSubjectAverages, allSubjectOverallStats, units);


        return { 
            subjectAverages: allSubjectAverages, 
            termAverages: allTermAverages, 
            globalAverage, 
            globalStdDev, 
            globalConsistencyScore, 
            subjectStats: allSubjectStats,
            subjectOverallStats: allSubjectOverallStats,
            subjectTrends,
            burnoutRiskScore,
            predictions
        };
    }
    
    function calculateBurnoutRisk(niveau, termAverages, globalStdDev, allSubjectOverallStats, units) {
        if (!niveau) return 0;
        
        // Component 1: Workload (Units) - Max 30 points
        let totalUnits = Object.values(units).reduce((sum, u) => sum + (u || 0), 0);
        let workloadScore = Math.min(30, (totalUnits / 30) * 30); 

        // Component 2: Global Volatility (StdDev) - Max 40 points
        let volatilityScore = Math.min(40, globalStdDev * 2.5); 

        // Component 3: Grade Drop - Max 30 points
        let dropScore = 0;
        const avg1 = termAverages.etape1;
        const avg2 = termAverages.etape2;
        if (avg1 !== null && avg2 !== null) {
            const gradeDrop = avg1 - avg2;
            dropScore = Math.min(30, Math.max(0, gradeDrop * 3)); 
        } else {
             // Use Subject Volatility as a proxy for drop risk
             let totalStdDev = 0;
             let count = 0;
             Object.values(allSubjectOverallStats).forEach(s => {
                 if (s.stdDev > 0) { totalStdDev += s.stdDev; count++; }
             });
             if (count > 0) dropScore = Math.min(30, (totalStdDev / count) * 2);
        }

        return Math.min(100, workloadScore + volatilityScore + dropScore);
    }
    
    // --- MONTE CARLO CORE LOGIC ---
    function runMonteCarloSimulation(globalAverage, termAverages, subjectAverages, subjectOverallStats, units) {
        const globalPred = { theoreticalMax: null, optimistic: null, trend: null, pessimistic: null, minPass: null };
        const subjectPreds = {};
        const targets = [95, 92, 90, 88, 85, 80, 75, 70, 60];
        const probabilityAnalysis = {};
        
        const avg1 = termAverages.etape1;
        const avg2 = termAverages.etape2;

        let currentKnownGlobalSum = 0;
        let totalKnownWeight = 0;
        
        if (avg1 !== null) {
            currentKnownGlobalSum += avg1 * TERM_WEIGHTS.etape1;
            totalKnownWeight += TERM_WEIGHTS.etape1;
        }
        if (avg2 !== null) {
            currentKnownGlobalSum += avg2 * TERM_WEIGHTS.etape2;
            totalKnownWeight += TERM_WEIGHTS.etape2;
        }
        
        const totalWeight = TERM_WEIGHTS.etape1 + TERM_WEIGHTS.etape2 + TERM_WEIGHTS.etape3;
        const remainingWeight = totalWeight - totalKnownWeight;

        if (remainingWeight === 0 && globalAverage !== null) {
             globalPred.theoreticalMax = globalPred.optimistic = globalPred.trend = globalPred.pessimistic = globalPred.minPass = globalAverage;
             targets.forEach(t => {
                probabilityAnalysis[t] = { requiredAvg: null, prob: globalAverage >= t ? 100 : 0 };
             });
             return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
        }
        if (globalAverage === null) return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };

        // --- 1. Calculate Required Average for Etape 3 (Deterministic) ---
        targets.forEach(target => {
            const requiredAvg = (target * totalWeight - currentKnownGlobalSum) / remainingWeight;
            
            // Simplified probability (based on Z-Score, using best current avg as proxy)
            const currentTrendAvg = avg2 !== null ? avg2 : (avg1 !== null ? avg1 : target); 
            const stdDevProxy = subjectOverallStats && Object.values(subjectOverallStats).length > 0 ? 
                                Object.values(subjectOverallStats).reduce((sum, s) => sum + s.stdDev, 0) / Object.values(subjectOverallStats).length : 5;
            
            const prob = calculateProbability(currentTrendAvg, stdDevProxy, requiredAvg);

            probabilityAnalysis[target] = { requiredAvg: requiredAvg, prob: prob };
        });


        // --- 2. Monte Carlo Simulation (Stochastic) ---
        let finalGrades = [];
        let subjectSumGrades = {};

        const relevantSubjects = Object.keys(subjectOverallStats).filter(code => units[code] && (subjectAverages.etape1?.[code] || subjectAverages.etape2?.[code]));
        
        relevantSubjects.forEach(code => subjectSumGrades[code] = 0);

        // Run N simulations
        for (let i = 0; i < NUM_MONTE_CARLO_RUNS; i++) {
            let simKnownSum = currentKnownGlobalSum;
            let simRemainingSum = 0;
            let simTotalUnitWeight = 0;
            
            relevantSubjects.forEach(code => {
                const subjStats = subjectOverallStats[code];
                const subjAvg1 = subjectAverages.etape1?.[code]?.average || null;
                const subjAvg2 = subjectAverages.etape2?.[code]?.average || null;
                const unit = units[code] || 2;
                
                let trendAvg = subjAvg2 !== null ? subjAvg2 : (subjAvg1 !== null ? subjAvg1 : 70); // Default to 70 if no data
                let stdDev = subjStats.stdDev;
                
                // Adjustment for low consistency (higher risk = higher SD for prediction)
                const consistencyFactor = Math.max(0.1, 1 - (subjStats.overallConsistency / 100)); // 0.1 (perfect) to 1.0 (bad)
                stdDev = stdDev * (1 + consistencyFactor * 0.5); // Increase SD by up to 50% for high risk

                // Generate a random grade for E3 based on trend average and modified SD
                // Uses Box-Muller transform for normal distribution approximation (random() generates uniform)
                let z = Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random());
                let predictedE3Avg = Math.min(100, Math.max(0, trendAvg + z * stdDev));

                // Final grade for subject in this simulation: (E1+E2 + E3) / Total
                let subjKnownSum = 0;
                if (subjAvg1 !== null) subjKnownSum += subjAvg1 * TERM_WEIGHTS.etape1;
                if (subjAvg2 !== null) subjKnownSum += subjAvg2 * TERM_WEIGHTS.etape2;
                
                const simSubjFinalGrade = (subjKnownSum + predictedE3Avg * TERM_WEIGHTS.etape3) / totalWeight;
                
                subjectSumGrades[code] += simSubjFinalGrade;
                
                // Global Calculation
                simRemainingSum += predictedE3Avg * unit;
                simTotalUnitWeight += unit;
            });
            
            const predictedE3AvgGlobal = simTotalUnitWeight > 0 ? simRemainingSum / simTotalUnitWeight : 0;
            const finalGlobalGrade = (currentKnownGlobalSum + predictedE3AvgGlobal * remainingWeight) / totalWeight;
            
            finalGrades.push(finalGlobalGrade);
        }

        // --- 3. Final Monte Carlo Results ---
        
        // Global Trend (Average of all runs)
        const mcTrendAvg = finalGrades.reduce((a, b) => a + b) / NUM_MONTE_CARLO_RUNS;
        globalPred.trend = mcTrendAvg;

        // Calculate MC StdDev for Global
        const mcVariance = finalGrades.reduce((sum, grade) => sum + Math.pow(grade - mcTrendAvg, 2), 0) / NUM_MONTE_CARLO_RUNS;
        const mcStdDev = Math.sqrt(mcVariance);
        
        // Optimistic and Pessimistic (based on MC distribution)
        globalPred.optimistic = Math.min(100, mcTrendAvg + mcStdDev * 1.5);
        globalPred.pessimistic = Math.max(60, mcTrendAvg - mcStdDev * 1.0);

        // Max Th√©orique and Min Pass (deterministic, based on section 1)
        const required95Avg = probabilityAnalysis[95]?.requiredAvg;
        globalPred.theoreticalMax = (currentKnownGlobalSum + (100 * remainingWeight)) / totalWeight;
        
        const required60Avg = probabilityAnalysis[60]?.requiredAvg;
        globalPred.minPass = required60Avg !== null ? Math.max(60, (currentKnownGlobalSum + Math.max(0, required60Avg) * remainingWeight) / totalWeight) : globalPred.trend;

        // Subject Final Predictions
        relevantSubjects.forEach(code => {
            subjectPreds[code] = { 
                trend: subjectSumGrades[code] / NUM_MONTE_CARLO_RUNS,
                stdDev: subjectOverallStats[code].stdDev,
                consistency: subjectOverallStats[code].overallConsistency
            };
        });
        
        // Re-evaluate probability based on MC trend and its own SD
        targets.forEach(target => {
            const prob = calculateProbability(globalPred.trend, mcStdDev, probabilityAnalysis[target].requiredAvg);
            probabilityAnalysis[target].prob = prob;
        });


        return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
    }

    // Approx. Probability based on Z-Score (CDF)
    function calculateProbability(mean, stdDev, requiredTarget) {
        if (mean === null) return 0;
        if (stdDev === 0) return mean >= requiredTarget ? 100 : 0;
        
        const z = (requiredTarget - mean) / stdDev;

        // Quick approximation of CDF from Z-Score
        if (z < -3.0) return 99; 
        if (z < -2.5) return 98;
        if (z < -2.0) return 95; 
        if (z < -1.5) return 93; 
        if (z < -1.0) return 84; 
        if (z < -0.5) return 69; 
        if (z < 0.0) return 50;  
        if (z < 0.5) return 31;
        if (z < 1.0) return 16;
        if (z < 1.5) return 7;
        if (z < 2.0) return 5;
        if (z < 2.5) return 2;
        return 1; 
    }


    // --- EVENT LISTENERS ---
    function setupEventListeners() {
        // Tabs
        document.querySelectorAll('.tab-btn').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelector('.tab-btn.active')?.classList.remove('active');
                tab.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                activeTab = tab.dataset.tab;
                document.getElementById(activeTab)?.classList.add('active');
                
                renderSidePanel(cachedAnalysis);
            });
        });

        // Settings
        document.getElementById('niveau-secondaire')?.addEventListener('change', saveSettings);
        document.getElementById('unites-mode')?.addEventListener('change', () => {
            saveSettings();
            populateUnitesModal();
        });

        // Modals
        const unitesModal = document.getElementById('unites-modal');
        document.getElementById('unites-btn')?.addEventListener('click', () => {
            populateUnitesModal();
            unitesModal?.classList.add('active');
        });
        document.getElementById('close-unites-modal')?.addEventListener('click', () => {
            saveCustomUnits();
            unitesModal?.classList.remove('active');
        });
    }
    
    function populateUnitesModal() {
        const unitesListEl = document.getElementById('unites-list');
        if (!unitesListEl) return;
        
        unitesListEl.innerHTML = '';

        const currentUnits = getUnits();
        const subjectCodes = new Set();

        ['etape1', 'etape2', 'etape3'].forEach(etapeKey => {
            mbsData[etapeKey]?.forEach(subject => {
                const codePrefix = subject.code.substring(0, 3);
                subjectCodes.add(codePrefix);
            });
        });

        Array.from(subjectCodes).sort().forEach(code => {
            const currentUnitValue = currentUnits[code] || 1;
            const li = document.createElement('div');
            li.className = 'unite-item flex justify-between items-center border-b border-gray-200 py-2';
            li.innerHTML = `
                <span class="text-gray-700">${subjectList[code] || code} (${code})</span>
                <input type="number" class="w-20 text-right p-1 border rounded-md" value="${currentUnitValue}" min="0" max="10" data-code="${code}">
            `;
            unitesListEl.appendChild(li);
        });
    }

    // --- START THE APP ---
    init();
});
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grade Projector: Final Algorithmic Limit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for dark mode and specific colors */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #0d1117; 
            color: #c9d1d9; 
        }
        .container { max-width: 1200px; }
        .card { 
            background-color: #161b22; 
            border-radius: 12px; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.08); 
            border: 1px solid #30363d;
        }
        .btn-primary { background-color: #238636; color: white; transition: background-color 0.2s; }
        .btn-primary:hover { background-color: #2ea043; }
        .progress-bar-fill { transition: width 0.4s ease-in-out, background-color 0.4s; }
        
        /* Monte Carlo probability colors */
        .prob-high { background-color: #235d3d; } 
        .prob-mid { background-color: #925c0e; } 
        .prob-low { background-color: #6d2e32; } 

        /* Scenarios table styling */
        .scenario-header { background-color: #21262d; color: #79c0ff; }
        .subject-header { background-color: #161b22; color: #c9d1d9; }
        
        .text-95 { color: #38a169; } /* Green for 95+ */
        .text-85 { color: #ecc94b; } /* Yellow for 85+ */
        .text-75 { color: #f6ad55; } /* Orange for 75+ */
        .text-60 { color: #e53e3e; } /* Red for 60+ */

        .table-scroll-container {
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container mx-auto space-y-8">
        <header class="text-center">
            <h1 class="text-4xl font-extrabold text-[#79c0ff]">ðŸš€ Grade Projector: FINAL LIMIT (v4)</h1>
            <p class="text-[#8b949e] mt-2">Running advanced EWM, Volatility, and Monte Carlo models on **localStorage.mbsdata**.</p>
        </header>

        <!-- Status and Progress Display -->
        <div class="card p-5 space-y-3">
            <h2 class="text-xl font-semibold text-[#79c0ff]">Calculation Status</h2>
            <div class="h-3 bg-gray-600 rounded-full overflow-hidden">
                <div id="progressBar" class="h-full bg-green-500 rounded-full progress-bar-fill" style="width: 0%;"></div>
            </div>
            <p id="statusMessage" class="text-sm font-medium text-[#8b949e]">Checking local storage for data...</p>
        </div>

        <!-- Control Panel -->
        <div class="card p-5 flex justify-center space-x-4">
            <button id="startButton" class="btn-primary px-8 py-4 text-xl font-bold rounded-full disabled:opacity-50 shadow-lg hover:shadow-xl" onclick="startSimulation()">
                RUN MAX-ACCURACY SIMULATION
            </button>
            <button id="mockButton" class="px-8 py-4 text-xl font-bold rounded-full disabled:opacity-50 shadow-lg hover:shadow-xl bg-gray-600 hover:bg-gray-700" onclick="mockDataLoad()">
                LOAD MOCK DATA EXAMPLE
            </button>
        </div>

        <!-- Results Display -->
        <div id="resultsContainer" class="card p-6 hidden">
            <h2 class="text-3xl font-bold text-white mb-4 border-b border-[#30363d] pb-3">Projection Results</h2>
            <div id="gpiDisplay" class="mb-4 text-xl font-medium text-[#c9d1d9]"></div>
            
            <!-- Monte Carlo Section -->
            <h3 class="text-2xl font-semibold mt-8 mb-4 text-red-400">Monte Carlo Probability Forecasts (5,000 Trials)</h3>
            <p class="text-sm text-[#8b949e] mb-3">Chance of achieving the following global final averages based on current trends and volatility:</p>
            <div id="monteCarloBody" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-3 text-center">
                <!-- Probabilities go here -->
            </div>
            
            <h3 class="text-2xl font-semibold mt-10 mb-4 text-[#79c0ff]">Annual Average Scenarios</h3>
            <p class="text-sm text-[#8b949e] mb-3">Projected final average based on different assumed performance levels on remaining work:</p>
            <table class="min-w-full divide-y divide-[#30363d] rounded-lg overflow-hidden">
                <thead class="scenario-header">
                    <tr>
                        <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider">Scenario</th>
                        <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider hidden lg:table-cell">Strategy Description</th>
                        <th class="px-4 py-3 text-right text-xs font-medium uppercase tracking-wider">Projected Avg</th>
                    </tr>
                </thead>
                <tbody id="scenarioBody" class="divide-y divide-[#30363d] bg-[#161b22]">
                    <!-- Scenarios go here -->
                </tbody>
            </table>
            
            <h3 class="text-2xl font-semibold mt-10 mb-4 text-[#79c0ff]">Deep Subject-Level Trend Analysis</h3>
            <p class="text-sm text-[#8b949e] mb-3">Analysis uses Exponentially Weighted Mean (EWM), Volatility, and Momentum scoring for predictive accuracy.</p>
            <div class="overflow-x-auto table-scroll-container">
                <table class="min-w-full divide-y divide-[#30363d] rounded-lg overflow-hidden">
                    <thead class="subject-header sticky top-0 z-10">
                        <tr>
                            <th class="px-3 py-2 text-left text-xs font-medium uppercase tracking-wider">Subject</th>
                            <th class="px-3 py-2 text-right text-xs font-medium uppercase tracking-wider">Current Avg</th>
                            <th class="px-3 py-2 text-right text-xs font-medium uppercase tracking-wider">EWM ($\lambda=0.9$)</th>
                            <th class="px-3 py-2 text-right text-xs font-medium uppercase tracking-wider">Volat. ($\sigma$)</th>
                            <th class="px-3 py-2 text-right text-xs font-medium uppercase tracking-wider">Comp. Volat.</th>
                            <th class="px-3 py-2 text-right text-xs font-medium uppercase tracking-wider">Effort (0-10)</th>
                            <th class="px-3 py-2 text-right text-xs font-medium uppercase tracking-wider">Momentum</th>
                            <th class="px-3 py-2 text-right text-xs font-medium uppercase tracking-wider">Realist. Final</th>
                        </tr>
                    </thead>
                    <tbody id="subjectBody" class="divide-y divide-[#30363d] bg-[#161b22]">
                        <!-- Subject details go here -->
                    </tbody>
                </table>
            </div>
            
            <h3 class="text-2xl font-semibold mt-10 mb-4 text-[#79c0ff]">Required Final Grade for Subject Pass/Honors</h3>
            <p class="text-sm text-[#8b949e] mb-3">The minimum percentage required on all *remaining* assignments to hit major benchmarks:</p>
            <div id="requiredGradesBody" class="space-y-4">
                <!-- Required Grades go here -->
            </div>
        </div>
    </div>

    <script>
        // --- CORE CONSTANTS & MAPPING ---
        const TARGET_GRADES = [95, 90, 85, 80, 75, 70, 60];
        const termWeights = { etape1: 0.20, etape2: 0.20, etape3: 0.60 };
        const gradeMap = { 'A+': 100, 'A': 95, 'A-': 90, 'B+': 85, 'B': 80, 'B-': 75, 'C+': 70, 'C-': 60, 'D+': 55, 'D': 50, 'E': 45 };
        const MONTE_CARLO_TRIALS = 5000;
        const EWM_LAMBDA = 0.9; // Exponential Weighting Factor: 0.9 strongly favors recent grades

        const defaultUnits = {
            sec4: { 'ART': 2, 'MUS': 2, 'FRA': 6, 'ELA': 4, 'MAT': 6, 'HQC': 4, 'CCQ': 2, 'EPS': 2 },
            sec5: { 'ART': 2, 'FRA': 6, 'ELA': 6, 'MAT': 6, 'PHY': 4, 'MON': 2, 'EPS': 2 }
        };
        const subjectList = { 'ART': "Arts Plastiques", 'FRA': "FranÃ§ais", 'ELA': "English Language Arts", 'MAT': "MathÃ©matiques", 'PHY': "Physique", 'MON': "Monde Contemporain", 'HQC': "Histoire", 'CCQ': "Culture et CitoyennetÃ©", 'EPS': "Ã‰ducation Physique" };


        // --- MOCK DATA FOR FALLBACK/DEMO ---
        const MOCK_DATA = {
            settings: { niveau: 'sec5', unitesMode: 'officiel' },
            etape1: [
                { code: 'FRA-5', name: 'FranÃ§ais', competencies: [{ name: 'Comp 1 (40%)', assignments: [{ result: '80%', pond: '10' }, { result: '65/100', pond: '20' }] }, { name: 'Comp 2 (60%)', assignments: [{ result: 'A', pond: '15' }] }] },
                { code: 'MAT-5', name: 'MathÃ©matiques', competencies: [{ name: 'Comp 1 (100%)', assignments: [{ result: '90%', pond: '30' }, { result: '75%', pond: '10' }] }] },
                { code: 'PHY-5', name: 'Physique', competencies: [{ name: 'Comp 1 (100%)', assignments: [{ result: '55%', pond: '20' }, { result: '70%', pond: '10' }] }] }
            ],
            etape2: [
                { code: 'FRA-5', name: 'FranÃ§ais', competencies: [{ name: 'Comp 1 (40%)', assignments: [{ result: '70%', pond: '15' }, { result: '92%', pond: '15' }] }, { name: 'Comp 2 (60%)', assignments: [{ result: 'B-', pond: '20' }] }] },
                { code: 'MAT-5', name: 'MathÃ©matiques', competencies: [{ name: 'Comp 1 (100%)', assignments: [{ result: '85%', pond: '25' }, { result: '95%', pond: '15' }] }] },
                { code: 'PHY-5', name: 'Physique', competencies: [{ name: 'Comp 1 (100%)', assignments: [{ result: '60/80', pond: '20' }] }] }
            ],
            etape3: [
                { 
                    code: 'FRA-5', name: 'FranÃ§ais', 
                    competencies: [
                        { name: 'Comp 1 (40%)', assignments: [{ result: '88%', pond: '10' }, { result: '', pond: '20' }] }, // Needs projection
                        { name: 'Comp 2 (60%)', assignments: [{ result: '', pond: '30' }] } // Needs projection
                    ]
                },
                { 
                    code: 'MON-5', name: 'Monde Contemporain', 
                    competencies: [
                        { name: 'Comp 1 (100%)', assignments: [{ result: '', pond: '40' }, { result: '', pond: '60' }] } // All missing grades
                    ]
                },
                { 
                    code: 'PHY-5', name: 'Physique', 
                    competencies: [
                        { name: 'Comp 1 (100%)', assignments: [{ result: '50%', pond: '20' }, { result: '', pond: '30' }] } // Needs projection, low recent grade
                    ]
                }
            ]
        };


        // --- UTILITIES & PRE-PROCESSING ---

        function getNumericGrade(result) {
            if (!result) return null;
            const trimmed = result.trim();
            if (gradeMap[trimmed]) return gradeMap[trimmed];
            const percentageMatch = trimmed.match(/(\d+[,.]?\d*)\s*%/);
            if (percentageMatch) return parseFloat(percentageMatch[1].replace(',', '.'));
            const scoreMatch = trimmed.match(/(\d+[,.]?\d*)\s*\/\s*(\d+[,.]?\d*)/);
            if (scoreMatch) {
                const score = parseFloat(scoreMatch[1].replace(',', '.'));
                const max = parseFloat(scoreMatch[2].replace(',', '.'));
                return (max > 0) ? (score / max) * 100 : null;
            }
            return null;
        }

        function getUnits(data) {
            const { unitesMode, customUnites } = data.settings || {};
            if (unitesMode === 'sans') return new Proxy({}, { get: () => 1 });
            if (unitesMode === 'perso') return customUnites || {};
            const niveauKey = data.settings?.niveau;
            return (niveauKey && defaultUnits[niveauKey]) ? defaultUnits[niveauKey] : {};
        }

        function preProcessData(data) {
            const preProcessed = JSON.parse(JSON.stringify(data));
            const allSubjectCodes = new Set();
            
            ['etape1', 'etape2', 'etape3'].forEach(etape => {
                if (preProcessed[etape]) {
                    preProcessed[etape].forEach(subject => {
                        const codePrefix = subject.code.substring(0, 3);
                        allSubjectCodes.add(codePrefix);

                        subject.competencies.forEach(comp => {
                            comp.assignments.forEach(assign => {
                                assign.numericGrade = getNumericGrade(assign.result);
                                assign.isCalculated = assign.numericGrade !== null;
                            });
                        });
                    });
                }
            });
            preProcessed.allSubjectCodes = Array.from(allSubjectCodes);
            return preProcessed;
        }
        
        function mockDataLoad() {
            if (typeof localStorage !== 'undefined') {
                 localStorage.setItem('mbsdata', JSON.stringify(MOCK_DATA));
                 document.getElementById('statusMessage').textContent = 'Mock data loaded into localStorage. Press RUN to simulate.';
            } else {
                 document.getElementById('statusMessage').textContent = 'LocalStorage not available. Cannot load mock data.';
            }
        }


        // --- CORE GRADE CALCULATIONS (Robust to missing terms/subjects) ---

        function calculateSubjectAverage(subject, projectionGradeFunc = null) {
            let totalWeightedContribution = 0; // The sum of (Competency Avg * Comp Weight)
            let totalWeightPossible = 0; 
            let totalRemainingWeight = 0;

            subject.competencies.forEach(comp => {
                const compWeightMatch = comp.name.match(/\((\d+)%\)/);
                const compWeight = compWeightMatch ? parseFloat(compWeightMatch[1]) : 0;
                if (compWeight === 0) return;
                
                totalWeightPossible += compWeight;

                let totalAssignmentGrade = 0;
                let totalAssignmentWeight = 0;
                let compRemainingWeight = 0;
        
                comp.assignments.forEach(assign => {
                    let weight = parseFloat(assign.pond) || 0; 
        
                    if (assign.isCalculated) {
                        totalAssignmentGrade += assign.numericGrade * weight;
                        totalAssignmentWeight += weight;
                    } else {
                        compRemainingWeight += weight;
                        if (projectionGradeFunc) {
                            let projectedGrade = projectionGradeFunc(subject, comp, assign);
                            if (projectedGrade !== null && !isNaN(projectedGrade)) {
                                totalAssignmentGrade += projectedGrade * weight;
                                totalAssignmentWeight += weight;
                            }
                        }
                    }
                });
        
                // Calculate the competency completion ratio
                const totalCompWeight = totalAssignmentWeight + compRemainingWeight;
                if (totalCompWeight > 0) {
                    const compAvg = totalAssignmentWeight > 0 ? (totalAssignmentGrade / totalAssignmentWeight) : 0;
                    const completionRatio = totalAssignmentWeight / totalCompWeight;

                    // Weighted contribution is Comp Avg * Comp Weight * Completion Ratio
                    // This is complex because we are mixing weights (100 total) and unit percentages (40%/60%)
                    totalWeightedContribution += compAvg * compWeight * completionRatio;
                    
                    // Total remaining weight for the subject is the sum of the non-completed parts
                    totalRemainingWeight += (compRemainingWeight / totalCompWeight) * compWeight;
                } else if (compWeight > 0) {
                    // If no assignments are recorded at all, the entire weight is remaining
                    totalRemainingWeight += compWeight;
                }
            });
            
            // The final average is the total weighted contribution (out of totalWeightPossible)
            const finalAverage = totalWeightPossible > 0 ? Math.min(100, totalWeightedContribution / totalWeightPossible * 100) : null;
            
            return { average: finalAverage, remainingWeight: totalRemainingWeight };
        }
        
        function calculateTermAverage(termData, units, projectionGradeFunc = null) {
            if (!termData || termData.length === 0) return { average: null, subjects: {} };
            let termWeightedSum = 0;
            let termUnitSum = 0;
        
            termData.forEach(subject => {
                const { average } = calculateSubjectAverage(subject, projectionGradeFunc);
                const codePrefix = subject.code.substring(0, 3);
                const unit = units[codePrefix] || 2; // Default to 2 units if missing
                
                if (average !== null) {
                    termWeightedSum += average * unit;
                    termUnitSum += unit;
                }
            });
        
            const termAverage = termUnitSum > 0 ? termWeightedSum / termUnitSum : null;
            return { average: termAverage };
        }

        // --- DEEP SUBJECT ANALYSIS ---

        function analyzeSubjectTrend(codePrefix, data) {
            let allAssignments = [];
            let compGrades = {};
            let currentSubjectTermData = [];

            // 1. Collect all grades across all terms for the subject, keeping order
            ['etape1', 'etape2', 'etape3'].forEach(etape => {
                const subject = data[etape] ? data[etape].find(s => s.code.startsWith(codePrefix)) : null;
                if (subject) {
                    currentSubjectTermData.push(subject);
                    subject.competencies.forEach(comp => {
                        const compName = comp.name.split('(')[0].trim();
                        if (!compGrades[compName]) compGrades[compName] = [];
        
                        comp.assignments.forEach(assign => {
                            if (assign.isCalculated) {
                                allAssignments.push(assign.numericGrade);
                                compGrades[compName].push(assign.numericGrade);
                            }
                        });
                    });
                }
            });
        
            if (allAssignments.length === 0) {
                // If a subject exists but has no grades (e.g., brand new Etape 3 course)
                const subjectData = data.etape3.find(s => s.code.startsWith(codePrefix)) || { competencies: [] };
                const { remainingWeight } = calculateSubjectAverage(subjectData);
                return { ewm: null, stdDev: 0, compVolat: 0, effortScore: 0, momentum: 0, remainingWeight: remainingWeight.toFixed(1), currentAvg: null };
            }
            
            // 2. Exponentially Weighted Mean (EWM) - Focus on Recency
            let weightedSum = 0;
            let totalWeight = 0;
            allAssignments.slice().reverse().forEach((g, index) => { 
                const weight = Math.pow(EWM_LAMBDA, index); 
                weightedSum += g * weight;
                totalWeight += weight;
            });
            const ewm = totalWeight > 0 ? weightedSum / totalWeight : 0;
            
            // 3. Standard Deviation (Instability)
            const simpleMean = allAssignments.reduce((sum, g) => sum + g, 0) / allAssignments.length;
            const variance = allAssignments.reduce((sum, g) => sum + Math.pow(g - simpleMean, 2), 0) / allAssignments.length;
            const stdDev = Math.sqrt(variance);

            // 4. Competency Volatility (Variance of competency averages)
            const compAverages = Object.values(compGrades)
                .map(g => g.length > 0 ? g.reduce((s, x) => s + x, 0) / g.length : null)
                .filter(x => x !== null);
            let compVolat = 0;
            if (compAverages.length > 1) {
                const avgOfComps = compAverages.reduce((s, x) => s + x, 0) / compAverages.length;
                const compVariance = compAverages.reduce((s, x) => s + Math.pow(x - avgOfComps, 2), 0) / compAverages.length;
                compVolat = Math.sqrt(compVariance);
            }

            // 5. Effort Score (0-10) - Based on Improvement Momentum (last 5 grades)
            let effortScore = 0;
            const lastFive = allAssignments.slice(-5);
            if (lastFive.length >= 2) {
                const gradeChange = lastFive[lastFive.length - 1] - lastFive[0];
                effortScore = Math.min(10, Math.max(0, gradeChange / 2)); // 20% improvement gives max effort score of 10
            }

            // 6. Momentum Score (Recent performance vs. EWM)
            const lastThreeAvg = allAssignments.slice(-3).reduce((s, g) => s + g, 0) / allAssignments.slice(-3).length;
            const momentum = lastThreeAvg - ewm; 

            // 7. Current Subject Average and Remaining Weight
            const lastSubjectTerm = currentSubjectTermData.length > 0 ? currentSubjectTermData[currentSubjectTermData.length - 1] : null;
            const { average: currentAvg, remainingWeight } = lastSubjectTerm ? calculateSubjectAverage(lastSubjectTerm) : { average: simpleMean, remainingWeight: 100 };
        
            return { ewm, stdDev, compVolat, effortScore: effortScore.toFixed(1), momentum: momentum.toFixed(1), remainingWeight: remainingWeight.toFixed(1), currentAvg: currentAvg };
        }

        // --- SCENARIO DEFINITION & PROJECTION ---

        function getScenarioParameters(gpi, allSubjectTrends) {
            const trendValues = Object.values(allSubjectTrends).filter(t => t.ewm !== null);
            const globalStdDev = trendValues.map(t => t.stdDev).reduce((a, b) => a + b, 0) / trendValues.length || 0;
            const globalEffort = trendValues.map(t => parseFloat(t.effortScore)).reduce((a, b) => a + b, 0) / trendValues.length || 0;
            const globalMomentum = trendValues.map(t => parseFloat(t.momentum)).reduce((a, b) => a + b, 0) / trendValues.length || 0;
        
            const gpiClean = gpi !== null ? gpi : 75; // Default assumption if no data exists
            
            return {
                'Absolute Maximum (100%)': { 
                    description: "Assumes 100% on all remaining work. The theoretical ceiling.", 
                    gradeFloor: 100, trendStrategy: 'flat' 
                },
                'Hyper-Growth Trajectory': { 
                    description: `Trusts Momentum and Effort. EWM + Global Momentum + Effort Bonus. High risk/reward.`, 
                    gradeFloor: gpiClean, 
                    trendStrategy: 'momentumOptimistic'
                },
                'Realistic EWM Projection': { 
                    description: "The core predictive model. Uses the subject's EWM adjusted by its internal Volatility.", 
                    gradeFloor: gpiClean, // Baseline is current GPI
                    trendStrategy: 'ewmAdjusted'
                },
                'Steady-State (Low Volatility)': { 
                    description: "Ignores recent fluctuations. Uses long-term simple mean minus Competency Volatility.", 
                    gradeFloor: gpiClean - globalStdDev, 
                    trendStrategy: 'simpleMeanConservative'
                },
                'Minimal Effort (Pass Only 60%)': {
                    description: "Assumes only 60% is scored on all remaining assignments to determine minimum outcome.",
                    gradeFloor: 60,
                    trendStrategy: 'flat'
                },
                'Burnout/Crash Risk': {
                    description: "Worst-case scenario: Projects at EWM - StdDev (if Momentum is negative).",
                    gradeFloor: Math.max(50, gpiClean - (globalStdDev * 2)),
                    trendStrategy: 'volatilityWorstCase'
                }
            };
        }

        function generateProjectionGrade(subject, comp, scenario, allSubjectTrends) {
            const codePrefix = subject.code.substring(0, 3);
            const trend = allSubjectTrends[codePrefix];
            let baseGrade = scenario.gradeFloor;
        
            if (trend && trend.ewm !== null) {
                switch (scenario.trendStrategy) {
                    case 'flat':
                        baseGrade = scenario.gradeFloor;
                        break;
                    case 'ewmAdjusted':
                        // Realistic: EWM + (Effort * 0.2) - (StdDev * 0.3)
                        const effortBonus = parseFloat(trend.effortScore) * 0.2;
                        const volatilityPenalty = trend.stdDev * 0.3;
                        baseGrade = trend.ewm + effortBonus - volatilityPenalty; 
                        break;
                    case 'momentumOptimistic':
                        // High Growth: EWM + Momentum Score + Effort Bonus
                        baseGrade = trend.ewm + parseFloat(trend.momentum) + (parseFloat(trend.effortScore) * 0.3);
                        break;
                    case 'simpleMeanConservative':
                        // Steady-State: EWM - Comp Volatility
                        baseGrade = trend.ewm - trend.compVolat;
                        break;
                    case 'volatilityWorstCase':
                        // Crash Risk: EWM - StdDev - CompVolat (only if momentum is negative)
                        if (parseFloat(trend.momentum) < 0) {
                            baseGrade = trend.ewm - trend.stdDev - trend.compVolat;
                        } else {
                            baseGrade = trend.ewm - trend.stdDev * 0.5; // Still conservative
                        }
                        break;
                }
            }
            
            // Ensure the projection is within reasonable bounds
            let projectedGrade = Math.min(100, Math.max(50, baseGrade)); 
        
            return projectedGrade;
        }

        // --- REQUIRED GRADE CALCULATION (Per Subject) ---

        function calculateRequiredGrade(subject, targetGrade) {
            let totalWeightedContribution = 0; // Points earned so far out of 100 subject points
            let totalWeightPossible = 0; 
            let totalRemainingWeight = 0;

            subject.competencies.forEach(comp => {
                const compWeightMatch = comp.name.match(/\((\d+)%\)/);
                const compWeight = compWeightMatch ? parseFloat(compWeightMatch[1]) : 0;
                if (compWeight === 0) return;
                totalWeightPossible += compWeight;

                let currentCompGradeSum = 0;
                let currentCompWeight = 0;
                let remainingCompWeight = 0;

                comp.assignments.forEach(assign => {
                    let weight = parseFloat(assign.pond) || 0; 
                    if (assign.isCalculated) {
                        currentCompGradeSum += assign.numericGrade * weight;
                        currentCompWeight += weight;
                    } else {
                        remainingCompWeight += weight;
                    }
                });

                const compTotalWeight = currentCompWeight + remainingCompWeight;
                if (compTotalWeight > 0) {
                    // Contribution earned from completed portion of this competency
                    if (currentCompWeight > 0) {
                        const compAvg = currentCompGradeSum / currentCompWeight;
                        const completionRatio = currentCompWeight / compTotalWeight;
                        totalWeightedContribution += compAvg * compWeight * completionRatio;
                    }
                    
                    // Total remaining weight for the subject (as a sum of competency remaining weights)
                    totalRemainingWeight += (remainingCompWeight / compTotalWeight) * compWeight;
                }
            });
            
            // If subject is 100% complete
            if (totalRemainingWeight <= 0.01) {
                const finalAvg = totalWeightPossible > 0 ? totalWeightedContribution / totalWeightPossible * 100 : 0;
                return { required: finalAvg.toFixed(1) + '% (Final)', achievable: finalAvg >= targetGrade };
            }

            // Required Score = (Target Points - Points Earned So Far) / (Weight Remaining / 100)
            const pointsNeeded = targetGrade - (totalWeightedContribution / 100 * totalWeightPossible); // Points out of 100
            
            // Convert weights to a decimal factor for the calculation
            const weightRemainingDecimal = totalRemainingWeight / totalWeightPossible;

            // If the points needed are negative, the grade is already achieved
            if (pointsNeeded <= 0) {
                return { required: `Achieved`, achievable: true };
            }

            const requiredScore = pointsNeeded / weightRemainingDecimal;

            if (requiredScore > 100) {
                return { required: `Impossible (${requiredScore.toFixed(0)}%)`, achievable: false };
            } else {
                return { required: `${Math.max(0, requiredScore).toFixed(1)}%`, achievable: requiredScore <= 100 };
            }
        }
        
        // --- MONTE CARLO SIMULATION ---

        function normalRandom(mean, stdDev) {
            let u = 0, v = 0;
            while (u === 0) u = Math.random(); 
            while (v === 0) v = Math.random();
            const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return z * stdDev + mean;
        }

        function runMonteCarloSimulation(processedData, units, allSubjectTrends, gpi) {
            const successfulTrials = TARGET_GRADES.reduce((acc, target) => ({ ...acc, [target]: 0 }), {});

            const subjectsNeedingProjection = processedData.etape3.filter(subject => 
                subject.competencies.some(comp => comp.assignments.some(a => !a.isCalculated))
            );

            if (subjectsNeedingProjection.length === 0) {
                return TARGET_GRADES.reduce((acc, target) => ({ ...acc, [target]: (gpi >= target) ? 1.0 : 0.0 }), {});
            }

            for (let i = 0; i < MONTE_CARLO_TRIALS; i++) {
                let trialData = JSON.parse(JSON.stringify(processedData));
                
                // Random projection based on EWM/StdDev for subjects needing projection
                const randomProjectionFunc = (subject, comp, assign) => {
                    const codePrefix = subject.code.substring(0, 3);
                    const trend = allSubjectTrends[codePrefix];
                    if (!trend || trend.ewm === null || trend.stdDev === 0) return 70; 
                    
                    let projected = normalRandom(trend.ewm, trend.stdDev);
                    return Math.min(100, Math.max(50, projected));
                };

                // Apply random grades to missing Etape 3 assignments
                subjectsNeedingProjection.forEach(s => {
                    s.competencies.forEach(c => {
                        c.assignments.forEach(a => {
                            if (!a.isCalculated) {
                                a.numericGrade = randomProjectionFunc(s, c, a);
                                a.isCalculated = true;
                            }
                        });
                    });
                });

                // Calculate the final average for the trial
                let trialGlobalWeightedSum = 0;
                let trialTotalWeight = 0;

                ['etape1', 'etape2', 'etape3'].forEach(etape => {
                    // Use the original term data for E1/E2, and the randomized data for E3
                    const termData = trialData[etape];
                    
                    const termResult = calculateTermAverage(termData, units, randomProjectionFunc);
                    
                    if (termResult.average !== null) {
                        trialGlobalWeightedSum += termResult.average * termWeights[etape];
                        trialTotalWeight += termWeights[etape];
                    }
                });

                const finalAvg = trialTotalWeight > 0 ? trialGlobalWeightedSum / trialTotalWeight : gpi || 0;

                // Check against all targets
                TARGET_GRADES.forEach(target => {
                    if (finalAvg >= target) successfulTrials[target]++;
                });
            }

            const probabilities = {};
            TARGET_GRADES.forEach(target => {
                probabilities[target] = successfulTrials[target] / MONTE_CARLO_TRIALS;
            });
            return probabilities;
        }
        
        // --- UI UTILITIES ---

        function reportProgress(message, step, totalSteps) {
            const statusElement = document.getElementById('statusMessage');
            const progressElement = document.getElementById('progressBar');
            const percentage = totalSteps > 0 ? (step / totalSteps) * 100 : 0;
            
            statusElement.textContent = `(Step ${step}/${totalSteps}) ${message}...`;
            progressElement.style.width = `${percentage}%`;

            if (percentage >= 100) {
                progressElement.classList.remove('bg-green-500');
                progressElement.classList.add('bg-[#238636]');
            } else {
                 progressElement.classList.add('bg-green-500');
                 progressElement.classList.remove('bg-[#238636]');
            }
        }

        // --- MAIN ASYNCHRONOUS ORCHESTRATOR ---

        async function calculateAllProjections(data) {
            const units = getUnits(data);
            const totalSteps = 6; 
            let step = 0;
            
            // 1. Pre-process Data (normalizing grades, identifying all subjects)
            reportProgress("Pre-processing and normalizing all grades", ++step, totalSteps);
            const processedData = preProcessData(data);
            await new Promise(r => setTimeout(r, 50)); 
            
            // 2. Calculate Base Averages and Global Performance Index (GPI)
            reportProgress("Calculating base GPI and term averages", ++step, totalSteps);
            const { allTermAverages } = ['etape1', 'etape2', 'etape3'].reduce((acc, etape) => {
                const result = calculateTermAverage(processedData[etape], units);
                acc.allTermAverages[etape] = result.average;
                return acc;
            }, { allTermAverages: {} });

            let currentGlobalWeightedSum = 0;
            let totalWeight = 0;
            Object.entries(allTermAverages).forEach(([etape, avg]) => {
                if (avg !== null) {
                    currentGlobalWeightedSum += avg * termWeights[etape];
                    totalWeight += termWeights[etape];
                }
            });
            const gpi = totalWeight > 0 ? currentGlobalWeightedSum / totalWeight : null;
            await new Promise(r => setTimeout(r, 50)); 
        
            // 3. Deep Trend, Volatility, and Effort Analysis for all subjects
            reportProgress("Performing deep EWM, volatility, and momentum analysis for all subjects", ++step, totalSteps);
            const allSubjectTrends = processedData.allSubjectCodes.reduce((acc, code) => {
                acc[code] = analyzeSubjectTrend(code, processedData);
                return acc;
            }, {});
            await new Promise(r => setTimeout(r, 50)); 
            
            // 4. Run Global Scenarios 
            reportProgress("Running 6 multi-scenario global projections", ++step, totalSteps);
            const scenarios = getScenarioParameters(gpi, allSubjectTrends);
            const projectedFinalAverages = {};
            
            Object.entries(scenarios).forEach(([scenarioName, scenarioParams]) => {
                let scenarioWeightedSum = 0;
                let scenarioTotalWeight = 0;
                
                const projectionFunc = (subject, comp, assign) => generateProjectionGrade(subject, comp, scenarioParams, allSubjectTrends);
                
                ['etape1', 'etape2', 'etape3'].forEach(etape => {
                    const termData = processedData[etape] || [];
                    
                    // We calculate the term average with the scenario's projection function
                    const projectedTermResult = calculateTermAverage(termData, units, projectionFunc);
                    const termAvg = projectedTermResult.average;
        
                    if (termAvg !== null) {
                        scenarioWeightedSum += termAvg * termWeights[etape];
                        scenarioTotalWeight += termWeights[etape];
                    }
                });
        
                projectedFinalAverages[scenarioName] = scenarioTotalWeight > 0 ? scenarioWeightedSum / scenarioTotalWeight : null;
            });
            await new Promise(r => setTimeout(r, 50)); 

            // 5. Run Monte Carlo Simulation
            reportProgress(`Running Monte Carlo simulation (${MONTE_CARLO_TRIALS} trials) for all ${TARGET_GRADES.length} targets`, ++step, totalSteps);
            const monteCarloResults = runMonteCarloSimulation(processedData, units, allSubjectTrends, gpi);
            await new Promise(r => setTimeout(r, 50)); 

            // 6. Calculate Subject Required Grades
            reportProgress("Calculating required final scores for all subjects and targets", ++step, totalSteps);
            const subjectRequiredGrades = processedData.allSubjectCodes.reduce((acc, code) => {
                // Find the latest subject data (usually Etape 3) for the required grade calculation
                const subjectData = processedData.etape3.find(s => s.code.startsWith(code)); 
                if (subjectData) {
                    acc[code] = TARGET_GRADES.map(target => ({
                        target,
                        ...calculateRequiredGrade(subjectData, target)
                    }));
                }
                return acc;
            }, {});

            reportProgress("Finalizing results display", 6, 6);
            return { gpi, projectedFinalAverages, allSubjectTrends, monteCarloResults, subjectRequiredGrades };
        }

        // --- UI RENDER FUNCTIONS ---
        
        function renderResults(results) {
            const container = document.getElementById('resultsContainer');
            const gpiDisplay = document.getElementById('gpiDisplay');
            const scenarioBody = document.getElementById('scenarioBody');
            const subjectBody = document.getElementById('subjectBody');
            const monteCarloBody = document.getElementById('monteCarloBody');
            const requiredGradesBody = document.getElementById('requiredGradesBody');
            
            container.classList.remove('hidden');
            gpiDisplay.innerHTML = `<strong>Global Performance Index (GPI) based on completed work:</strong> <span class="text-green-400 font-bold text-2xl">${results.gpi ? results.gpi.toFixed(2) + '%' : 'N/A (No completed terms)'}</span>`;
            scenarioBody.innerHTML = '';
            subjectBody.innerHTML = '';
            monteCarloBody.innerHTML = '';
            requiredGradesBody.innerHTML = '';

            const scenarios = getScenarioParameters(results.gpi, results.allSubjectTrends);

            // RENDER 1: Scenarios
            Object.entries(results.projectedFinalAverages).forEach(([name, avg]) => {
                const row = document.createElement('tr');
                let avgClass = 'text-gray-400';
                if (avg > 90) avgClass = 'text-95 font-bold'; 
                else if (avg > 80) avgClass = 'text-85'; 
                else if (avg > 70) avgClass = 'text-75'; 
                else if (avg > 60) avgClass = 'text-60';
                
                row.innerHTML = `
                    <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-white">${name}</td>
                    <td class="px-4 py-3 text-sm text-[#8b949e] hidden lg:table-cell">${scenarios[name].description}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-base text-right ${avgClass}">${avg ? avg.toFixed(2) + '%' : 'N/A'}</td>
                `;
                scenarioBody.appendChild(row);
            });

            // RENDER 2: Monte Carlo
            TARGET_GRADES.forEach(target => {
                const prob = results.monteCarloResults[target] || 0;
                const probPct = (prob * 100).toFixed(1);
                let bgColor = 'prob-low';
                if (prob > 0.8) bgColor = 'prob-high';
                else if (prob > 0.5) bgColor = 'prob-mid';
                
                monteCarloBody.innerHTML += `
                    <div class="card p-3 ${bgColor} border-0">
                        <p class="text-3xl font-extrabold text-white">${probPct}%</p>
                        <p class="text-xs font-semibold text-gray-200 mt-1">Chance of ${target}+</p>
                    </div>
                `;
            });

            // RENDER 3: Subject Details
            Object.entries(results.allSubjectTrends).forEach(([code, trend]) => {
                const name = subjectList[code] || code;

                const row = document.createElement('tr');
                const avg = trend.currentAvg;
                let avgClass = 'text-gray-400';
                if (avg > 90) avgClass = 'text-95 font-bold'; 
                else if (avg > 80) avgClass = 'text-85'; 
                else if (avg > 70) avgClass = 'text-75'; 
                else if (avg > 60) avgClass = 'text-60';

                const momentumClass = parseFloat(trend.momentum) > 0 ? 'text-green-500' : 'text-red-500';
                
                row.innerHTML = `
                    <td class="px-3 py-3 whitespace-nowrap text-sm font-medium text-white">${name}</td>
                    <td class="px-3 py-3 whitespace-nowrap text-sm text-right ${avgClass}">${avg !== null ? avg.toFixed(1) + '%' : 'N/A'}</td>
                    <td class="px-3 py-3 whitespace-nowrap text-sm text-right text-indigo-400">${trend.ewm !== null ? trend.ewm.toFixed(1) + '%' : 'N/A'}</td>
                    <td class="px-3 py-3 whitespace-nowrap text-sm text-right text-yellow-400">${trend.stdDev.toFixed(1)}</td>
                    <td class="px-3 py-3 whitespace-nowrap text-sm text-right text-orange-400">${trend.compVolat.toFixed(1)}</td>
                    <td class="px-3 py-3 whitespace-nowrap text-sm text-right text-green-400">${trend.effortScore}</td>
                    <td class="px-3 py-3 whitespace-nowrap text-sm text-right ${momentumClass}">${trend.momentum}</td>
                    <td class="px-3 py-3 whitespace-nowrap text-sm text-right text-purple-400">${trend.ewm !== null ? trend.ewm.toFixed(2) + '%' : 'N/A'}</td>
                `;
                subjectBody.appendChild(row);
            });

            // RENDER 4: Required Grades (Per Subject)
            Object.entries(results.subjectRequiredGrades).forEach(([code, requiredTargets]) => {
                const name = subjectList[code] || code;
                const remainingWeight = results.allSubjectTrends[code].remainingWeight;

                if (parseFloat(remainingWeight) < 0.01) return; 

                const subjectCard = document.createElement('div');
                subjectCard.className = 'card p-4 mb-4';
                
                let content = `<h4 class="text-xl font-bold mb-2 text-white">${name} <span class="text-sm text-[#8b949e] ml-2">(${remainingWeight}% Remaining)</span></h4>`;
                content += '<div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-2 mt-3">';

                requiredTargets.forEach(req => {
                    let color = 'bg-gray-700';
                    if (req.required.includes('Achieved')) color = 'bg-green-700';
                    else if (req.required.includes('Impossible')) color = 'bg-red-700';
                    else if (parseFloat(req.required) <= 75) color = 'bg-green-600';
                    else if (parseFloat(req.required) <= 90) color = 'bg-yellow-600';
                    else color = 'bg-indigo-700';

                    content += `
                        <div class="p-2 rounded-lg text-center font-semibold ${color}">
                            <span class="text-xs font-light text-gray-200">Target ${req.target}%</span>
                            <div class="text-sm text-white mt-1">${req.required}</div>
                        </div>
                    `;
                });
                content += '</div>';
                subjectCard.innerHTML = content;
                requiredGradesBody.appendChild(subjectCard);
            });
            document.getElementById('statusMessage').textContent = `Simulation Complete. ${MONTE_CARLO_TRIALS} trials analyzed.`;
        }

        // --- SIMULATION START ---

        async function startSimulation() {
            const startButton = document.getElementById('startButton');
            const mockButton = document.getElementById('mockButton');
            startButton.disabled = true;
            mockButton.disabled = true;
            document.getElementById('resultsContainer').classList.add('hidden');
            
            try {
                // Load data, prioritizing localStorage
                let dataToUse = null;
                if (typeof localStorage !== 'undefined' && localStorage.getItem('mbsdata')) {
                    try {
                        dataToUse = JSON.parse(localStorage.getItem('mbsdata'));
                        if (!dataToUse || Object.keys(dataToUse).length === 0) {
                            throw new Error("Local storage data is empty or invalid.");
                        }
                        document.getElementById('statusMessage').textContent = 'Successfully loaded data from localStorage.mbsdata.';
                    } catch (e) {
                        dataToUse = MOCK_DATA;
                        console.error("Local storage parsing failed. Using mock data.", e);
                        document.getElementById('statusMessage').textContent = 'ERROR: localStorage.mbsdata could not be parsed. Using Mock Data.';
                    }
                } else {
                    dataToUse = MOCK_DATA;
                    document.getElementById('statusMessage').textContent = 'localStorage.mbsdata not found. Using Mock Data.';
                }
                
                const results = await calculateAllProjections(dataToUse);
                renderResults(results);
            } catch (error) {
                console.error("CRITICAL Simulation Error:", error);
                document.getElementById('statusMessage').textContent = `(CRITICAL ERROR) Simulation failed: ${error.message}. Check console for details.`;
            } finally {
                startButton.disabled = false;
                mockButton.disabled = false;
            }
        }

        // Initial setup check
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof localStorage !== 'undefined' && localStorage.getItem('mbsdata')) {
                document.getElementById('statusMessage').textContent = 'localStorage.mbsdata found. Ready to run maximum accuracy simulation.';
            } else {
                document.getElementById('statusMessage').textContent = 'localStorage.mbsdata NOT found. Press "Load Mock Data Example" or ensure your data is set, then press RUN.';
            }
        });
    </script>
</body>
</html>

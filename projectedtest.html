<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur Dynamique de Pr√©diction Stochastique</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Setup */
        :root {
            --primary-color: #7C3AED; /* Violet */
            --secondary-color: #10B981; /* Green */
            --warning-color: #F59E0B; /* Amber */
            --danger-color: #EF4444; /* Red */
            --bg-color: #f9fafb;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: #1f2937;
        }
        .main-container {
            display: flex;
            min-height: 100vh;
        }
        
        /* Side Panel (Summary/Averages) */
        .side-panel {
            width: 100%;
            max-width: 380px; 
            background-color: white;
            padding: 1.5rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            border-radius: 0.75rem;
            margin: 1rem;
            height: fit-content;
        }
        @media (max-width: 1024px) {
            .main-container { flex-direction: column; }
            .side-panel { max-width: 100%; }
        }

        /* Content Area (Tabs/Tables) */
        .content-area {
            flex-grow: 1;
            padding: 1rem;
        }
        .tab-btn {
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            border-radius: 0.375rem 0.375rem 0 0;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #eef2ff; /* Violet-50 */
            color: #4c1d95; /* Violet-900 */
            margin-right: 0.25rem;
        }
        .tab-btn.active {
            background-color: white;
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
            box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.05);
        }
        .tab-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0 0.75rem 0.75rem 0.75rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }
        .tab-content:not(.active) { display: none; }

        /* Subject Tables (Simplified for Analysis) */
        .subject-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 1.5rem; 
        }
        .subject-table thead th {
            padding: 0.75rem;
            text-align: left;
            background-color: var(--primary-color);
            color: white;
            font-weight: 700;
        }
        .subject-table thead tr:first-child th {
            font-size: 1.125rem;
            text-align: center;
        }
        .subject-table tbody tr:nth-child(even) { background-color: #f3f4f6; }
        .subject-table td {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .grade-percentage {
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Analysis Specifics */
        .subject-analysis {
            background-color: #f5f3ff; /* Purple-50 */
            border: 1px solid #e9d5ff; /* Purple-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: -1rem; 
            margin-bottom: 1.5rem;
        }
        .analysis-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }
        .badge-green { background-color: #D1FAE5; color: #065F46; } 
        .badge-yellow { background-color: #FEF3C7; color: #92400E; } 
        .badge-red { background-color: #FEE2E2; color: #991B1B; } 
        .badge-violet { background-color: #E9D5FF; color: #5B21B6; }
        .badge-blue { background-color: #DBEAFE; color: #1E40AF; }

        /* Prediction Cards */
        .prediction-card {
            background-color: #f7f7f7;
            padding: 1rem;
            border-radius: 0.5rem;
            border-left: 4px solid;
            margin-bottom: 1rem;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .card-green { border-left-color: var(--secondary-color); }
        .card-violet { border-left-color: var(--primary-color); }
        .card-yellow { border-left-color: var(--warning-color); }
        .card-red { border-left-color: var(--danger-color); }
        .card-score {
            font-size: 1.875rem; 
            font-weight: 800;
            margin-top: 0.25rem;
        }

        /* Probability Table */
        .probability-table th, .probability-table td {
            padding: 0.5rem;
            text-align: center;
            border: 1px solid #e5e7eb;
        }
        .prob-high { background-color: #D1FAE5; color: #065F46; font-weight: 700;}
        .prob-medium { background-color: #FEF3C7; color: #92400E; }
        .prob-low { background-color: #FEE2E2; color: #991B1B; }
        
        /* Modal - Simplified */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s ease-out;
            opacity: 0;
            pointer-events: none;
        }
        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }

        /* Scorecard style update */
        .score-card {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #f3f4f6;
            transition: all 0.15s;
        }
        .score-card strong {
            font-size: 1.5rem;
        }
        .score-icon {
            font-size: 1.5rem;
            margin-right: 1rem;
        }

    </style>
</head>
<body>

    <div class="main-container">

        <!-- Sidebar - R√©sum√© des notes -->
        <div class="side-panel lg:sticky lg:top-4">
            <h2 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2">Moteur Stochastique Pr√©dictif</h2>

            <div class="bg-violet-100 p-4 rounded-lg mb-4 border-l-4 border-violet-600">
                <p class="text-sm font-medium text-gray-700">Pr√©diction Globale Stochastique (Tendance MC)</p>
                <strong id="moyenne-prediction" class="text-4xl font-extrabold text-violet-700">--</strong>
            </div>
            
            <h3 class="text-lg font-semibold mt-6 mb-3 text-gray-800 border-t pt-3">Indices de Risque Dynamique</h3>
            <div id="deep-analysis-scorecard" class="space-y-3 mb-6">
                <!-- Consistency/Effort -->
                <div class="score-card score-high" id="consistency-score">
                    <span class="score-icon text-gray-600">üéØ</span>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Indice de Consistance/Volatilit√© (100 = Parfait)</p>
                        <strong class="text-xl text-gray-800">--</strong>
                    </div>
                </div>
                <!-- Burnout -->
                <div class="score-card score-low" id="burnout-risk-score">
                    <span class="score-icon text-red-600">üî•</span>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Score de Risque de Burnout (100 = Risque Maximal)</p>
                        <strong class="text-xl text-red-600">--</strong>
                    </div>
                </div>
            </div>

            <h3 class="text-lg font-semibold mt-4 mb-2 text-gray-700 border-t pt-3">Moyennes par Mati√®re (<span id="active-etape-name">1</span>)</h3>
            <ul id="subject-averages-list" class="space-y-2 text-base">
                <!-- Subject Averages will be rendered here -->
            </ul>

            <h3 class="text-lg font-semibold mt-4 mb-2 text-gray-700 border-t pt-3">Param√®tres Actuels</h3>
            <div class="space-y-3 mb-6 text-sm">
                <div>
                    <label for="niveau-secondaire" class="block text-sm font-medium text-gray-700">Niveau Secondaire</label>
                    <select id="niveau-secondaire" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm py-2 px-3 focus:ring-primary-500 focus:border-primary-500">
                        <option value="">S√©lectionner</option>
                        <option value="sec4">Secondaire 4</option>
                        <option value="sec5">Secondaire 5</option>
                    </select>
                </div>
                <div>
                    <label for="unites-mode" class="block text-sm font-medium text-gray-700">Mode Unit√©s (Pond√©ration)</label>
                    <div class="flex space-x-2">
                        <select id="unites-mode" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm py-2 px-3 focus:ring-primary-500 focus:border-primary-500">
                            <option value="defaut">D√©faut (Officiel)</option>
                            <option value="sans">Sans Unit√©s (Moy. Simple)</option>
                            <option value="perso">Personnalis√©</option>
                        </select>
                        <button id="unites-btn" class="bg-gray-200 text-gray-600 rounded-md px-3 hover:bg-gray-300 transition duration-150 text-sm">√âditer</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content - Tabs & Tables -->
        <div class="content-area">
            <h1 class="text-3xl font-bold mb-4 text-gray-800">D√©tails de Performance & Pr√©dictions</h1>

            <!-- Tabs -->
            <div class="flex border-b border-gray-200 mb-4">
                <button class="tab-btn active" data-tab="etape1">√âtape 1 - Analyse</button>
                <button class="tab-btn" data-tab="etape2">√âtape 2 - Analyse</button>
                <button class="tab-btn" data-tab="etape3">√âtape 3 - Projection</button>
                <button class="tab-btn" data-tab="simulation">Monte Carlo & Probabilit√©s</button>
            </div>

            <!-- Tab Contents -->
            <div id="tab-contents">
                <div id="etape1" class="tab-content active">
                    <!-- Data for Etape 1 will be rendered here -->
                </div>
                <div id="etape2" class="tab-content">
                    <!-- Data for Etape 2 will be rendered here -->
                </div>
                <div id="etape3" class="tab-content">
                    <!-- Data for Etape 3 will be rendered here -->
                </div>

                <!-- Monte Carlo Simulation Tab -->
                <div id="simulation" class="tab-content">
                    <h2 class="text-2xl font-bold mb-4 text-primary-color">Analyse Pr√©dictive Monte Carlo Avanc√©e</h2>
                    <p class="text-gray-600 mb-6 border-b pb-4">
                        *L'algorithme a ex√©cut√© <strong class="text-primary-color">10,000 sc√©narios probabilistes stochastiques par mati√®re</strong>, ajust√©s par la volatilit√© individuelle et le **Multiplicateur de Performance Pr√©dite (MPP)**. Pr√©cision limite absolue.*
                    </p>

                    <!-- Global Predictions (Confidence Intervals) -->
                    <h3 class="text-xl font-semibold mb-3 mt-4 text-gray-700">Pr√©dictions de Moyenne Finale Globale (Intervalles de Confiance)</h3>
                    <div id="global-predictions" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Predictions will be rendered here -->
                    </div>

                    <!-- Effort/Volatility Mismatch Analysis -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Analyse de D√©s√©quilibre Volatilit√© / Effort (Mismatch)</h3>
                    <div id="mismatch-analysis" class="space-y-4">
                        <!-- Mismatch analysis will be rendered here -->
                    </div>

                    <!-- Probability Analysis -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Analyse de Chemin : Moyenne Requise √† l'√âtape 3</h3>
                    <p class="text-sm text-gray-600 mb-4">Moyenne exacte que vous devez obtenir √† l'√âtape 3 pour atteindre chaque objectif global.</p>
                    <table class="probability-table w-full rounded-lg overflow-hidden">
                        <thead>
                            <tr class="bg-gray-100">
                                <th>Objectif Global (%)</th>
                                <th>Moyenne Requise E3 (%)</th>
                                <th>Probabilit√© (%)</th>
                                <th>Analyse du Risque</th>
                            </tr>
                        </thead>
                        <tbody id="probability-table-body">
                            <!-- Probabilities will be rendered here -->
                        </tbody>
                    </table>

                     <!-- Subject Predictions (Detailed) -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Pr√©dictions Tendancielles D√©tail√©es par Mati√®re</h3>
                    <p class="text-sm text-gray-600 mb-4">Pr√©diction de note finale (E1+E2+E3) si l'effort et la volatilit√© actuels se maintiennent (Tendance Stochastique).</p>
                    <div id="subject-predictions-list" class="space-y-3">
                        <!-- Subject predictions will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Unit Customization -->
    <div id="unites-modal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4">Unit√©s par Mati√®re</h3>
            <p class="text-sm text-gray-500 mb-4">Ajustez les unit√©s pour chaque mati√®re si le mode 'Personnalis√©' est s√©lectionn√©.</p>
            <div id="unites-list" class="max-h-80 overflow-y-auto border p-3 rounded-md space-y-2">
                <!-- Units will be populated here -->
            </div>
            <div class="mt-6 flex justify-end">
                <button id="close-unites-modal" class="bg-primary-color text-white px-4 py-2 rounded-md hover:bg-violet-700 transition">Fermer & Appliquer</button>
            </div>
        </div>
    </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {

    // --- CONSTANTS AND STATE ---
    const gradeMap = { 'A+': 100, 'A': 95, 'A-': 90, 'B+': 85, 'B': 80, 'B-': 75, 'C+': 70, 'C': 65, 'C-': 60, 'D+': 55, 'D': 50, 'E': 45 };
    const defaultUnits = {
        sec4: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'FRA': 6, 'ELA': 4, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 6, 'ST': 4, 'STE': 4, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'ENT': 2, 'INF': 2, 'PSY': 2 },
        sec5: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'CAT': 4, 'FRA': 6, 'ELA': 6, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 4, 'MED': 4, 'PSY': 4, 'ENT': 4, 'FIN': 4, 'CHI': 4, 'PHY': 4, 'MON': 2, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'FIN': 2 }
    };
    const subjectList = { 'ART': "Arts Plastiques", 'MUS': "Musique", 'DRM': "Art Dramatique", 'CAT': "Conception et Application Technologique", 'FRA': "Fran√ßais", 'ELA': "English Language Arts", 'EESL': "Anglais enrichi", 'ESL': "Anglais langue seconde", 'SN': "Math SN", 'CST': "Math CST", 'ST': "Science et Technologie", 'STE': "Science et Tech. Env.", 'HQC': "Histoire", 'CCQ': "Culture et Citoyennet√©", 'EPS': "√âducation Physique", 'CHI': "Chimie", 'PHY': "Physique", 'MON': "Monde Contemporain", 'MED': "M√©dia", 'ENT': "Entrepreneuriat", 'INF': "Informatique", 'PSY': "Psychologie", 'FIN': "√âducation Financi√®re" };
    
    const TERM_WEIGHTS = { etape1: 0.20, etape2: 0.20, etape3: 0.60 };

    let mbsData = {};
    let activeTab = 'etape1';
    let cachedAnalysis = null;
    const NUM_MONTE_CARLO_RUNS = 10000; // Pushing the limit of calculation

    // --- INITIALIZATION ---
    function init() {
        // Mock data initialization if needed for debugging or retrieve from Local Storage
        mbsData = JSON.parse(localStorage.getItem('mbsData')) || { 
            valid: true, nom: '√âtudiant', settings: { niveau: 'sec5', unitesMode: 'defaut' } 
        };

        if (!mbsData.valid || !mbsData.nom) {
            const mainContainer = document.querySelector('.main-container');
            if (mainContainer) {
                mainContainer.innerHTML = `<p style="text-align:center; width:100%; padding: 4rem;">Donn√©es non charg√©es. Veuillez vous assurer que les donn√©es sont enregistr√©es sous 'mbsData' dans le Local Storage.</p>`;
            }
            return;
        }

        loadSettings();
        calculateAndCacheAnalysis();
        renderAll();
        setupEventListeners();
    }

    // --- DATA & SETTINGS MANAGEMENT ---
    function loadSettings() {
        const settings = mbsData.settings || {};
        document.getElementById('niveau-secondaire').value = settings.niveau || '';
        document.getElementById('unites-mode').value = settings.unitesMode || 'defaut';
    }

    function saveSettings() {
        mbsData.settings = mbsData.settings || {};
        mbsData.settings.niveau = document.getElementById('niveau-secondaire').value;
        mbsData.settings.unitesMode = document.getElementById('unites-mode').value;
        mbsData.settings.customUnites = mbsData.settings.customUnites || {};
        
        localStorage.setItem('mbsData', JSON.stringify(mbsData));
        calculateAndCacheAnalysis();
        renderAll();
    }
    
    function saveCustomUnits() {
        const unitesModeEl = document.getElementById('unites-mode');
        if (unitesModeEl.value !== 'perso') return;

        let customUnites = {};
        document.querySelectorAll('.unite-item input').forEach(input => {
            customUnites[input.dataset.code] = parseFloat(input.value) || 1;
        });
        
        mbsData.settings = mbsData.settings || {};
        mbsData.settings.customUnites = customUnites;
        saveSettings();
    }

    // --- RENDERING FUNCTIONS ---
    function renderAll() {
        renderTermTables();
        const analysis = cachedAnalysis;
        renderSidePanel(analysis);
        renderDeepAnalysis(analysis);
        renderMonteCarlo(analysis);
        renderMismatchAnalysis(analysis);
    }

    function renderTermTables() {
        ['etape1', 'etape2', 'etape3'].forEach(key => {
            const container = document.getElementById(key);
            // We use allSubjectStats from cachedAnalysis to ensure subject order consistency
            if (container) renderTermData(mbsData[key], container, key, cachedAnalysis);
        });
    }

    function renderTermData(termData, container, etapeKey, analysis) {
        if (!container) return; 

        if (!termData || termData.length === 0 || !analysis.subjectStats) {
            container.innerHTML = `<p class="no-data text-gray-500">Aucune donn√©e de base pour cette √©tape.</p>`;
            return;
        }
        container.innerHTML = '';
        
        // Use the comprehensive list of subjects from the overall stats to ensure all subjects are listed, 
        // even if they only appear in another term.
        const allSubjectsInTerm = Object.keys(analysis.subjectStats).filter(code => analysis.subjectStats[code]?.[etapeKey]);

        if (allSubjectsInTerm.length === 0) {
            container.innerHTML = `<p class="no-data text-gray-500">Aucune mati√®re avec donn√©es dans cette √©tape.</p>`;
            return;
        }


        // Render each subject that has data in this specific term
        allSubjectsInTerm.forEach(codePrefix => {
            const subject = mbsData[etapeKey].find(s => s.code.startsWith(codePrefix));
            const subjStats = analysis.subjectStats[codePrefix]?.[etapeKey];

            if (subject && subjStats) {
                // 1. Render Subject Table (Simplified)
                container.appendChild(renderSubjectTable(subject, etapeKey, subjStats));
                
                // 2. Render Subject Analysis
                container.appendChild(renderSubjectAnalysis(codePrefix, etapeKey, analysis));
            }
        });
    }

    function renderSubjectTable(subject, etapeKey, subjStats) {
        const table = document.createElement('table');
        table.className = 'subject-table';
        const codePrefix = subject.code.substring(0, 3);
        const subjectName = subjectList[codePrefix] || subject.name;
        
        table.innerHTML = `
            <thead>
                <tr><th colspan="3">${codePrefix} - ${subjectName}</th></tr>
                <tr>
                    <th>Comp√©tence</th>
                    <th>Moyenne Actuelle</th>
                    <th>Effort Interne (Consistance/100)</th>
                </tr>
            </thead>
            <tbody></tbody>`;
        const tbody = table.querySelector('tbody');

        // Only show competencies that had data processed
        subjStats.competencyAverages.forEach((comp, compIndex) => {
            const compAvg = comp.avg;
            const compConsistency = comp.consistency;

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${subject.competencies[compIndex].name}</td>
                <td>${compAvg !== null ? `<span class="grade-percentage">${compAvg.toFixed(2)}%</span>` : '<span class="no-data">N/D</span>'}</td>
                <td>
                    ${compConsistency !== null ? `
                        <span class="analysis-badge ${getConsistencyBadgeClass(compConsistency)}">${compConsistency.toFixed(0)}/100</span>
                    ` : '<span class="no-data">-</span>'}
                </td>
            `;
            if (tbody) tbody.appendChild(row);
        });
        return table;
    }

    function getConsistencyBadgeClass(score) {
        if (score >= 90) return 'badge-green';
        if (score >= 70) return 'badge-yellow';
        return 'badge-red';
    }

    function renderSubjectAnalysis(subjectCode, etapeKey, analysis) {
        const analysisDiv = document.createElement('div');
        analysisDiv.className = 'subject-analysis';
        
        const subjAvg = analysis.subjectAverages[etapeKey]?.[subjectCode]?.average;
        const subjStats = analysis.subjectStats[subjectCode]?.[etapeKey];
        const subjOverallStats = analysis.subjectOverallStats[subjectCode];
        const trend = analysis.subjectTrends?.[subjectCode];
        const prediction = analysis.predictions.subjects[subjectCode];

        if (subjAvg === null || subjAvg === undefined || !prediction) {
            analysisDiv.innerHTML = `<p class="text-sm text-gray-500">Aucune donn√©e pour l'analyse de ${subjectList[subjectCode]}.</p>`;
            return analysisDiv;
        }

        // 1. Overall Consistency Badge
        let overallConsistency = subjOverallStats?.overallConsistency || 0;
        let consistencyBadge = { label: 'Volatilit√© Max', class: 'badge-red', icon: '‚ùå' };
        if (overallConsistency >= 90) consistencyBadge = { label: 'Tr√®s Stable', class: 'badge-green', icon: '‚úÖ' };
        else if (overallConsistency >= 70) consistencyBadge = { label: 'Stable', class: 'badge-yellow', icon: '‚ö†Ô∏è' };
        
        // 2. Volatility (StdDev) Badge
        const stdDev = subjOverallStats?.stdDev || 0;
        let volatilityBadge = { label: `Volatilit√© : ${stdDev.toFixed(1)}%`, class: 'badge-violet', icon: '‚ôº' };
        if (stdDev > 10) volatilityBadge.class = 'badge-red';
        else if (stdDev > 5) volatilityBadge.class = 'badge-yellow';
        else volatilityBadge.class = 'badge-green';
        
        // 3. Trend Badge (Only if E2 exists)
        let trendBadge = { label: 'N/A', class: 'badge-violet', icon: ' ' };
        let trendDescription = '';

        if (trend && etapeKey !== 'etape1') {
            const diff = trend.diff;
            if (diff > 2) {
                trendBadge = { label: `Forte Hausse (+${diff.toFixed(1)}%)`, class: 'badge-green', icon: '‚¨ÜÔ∏è' };
                trendDescription = 'Forte am√©lioration. Le MPP est ajust√© √† la hausse.';
            } else if (diff < -2) {
                trendBadge = { label: `Baisse Importante (${diff.toFixed(1)}%)`, class: 'badge-red', icon: '‚¨áÔ∏è' };
                trendDescription = 'Baisse significative. Le MPP est ajust√© √† la baisse.';
            } else {
                trendBadge = { label: 'Stable', class: 'badge-yellow', icon: '‚ÜîÔ∏è' };
                trendDescription = 'Tendance stable. Le MPP est neutre.';
            }
        }

        // 4. MPP Badge
        const mpp = prediction.mpp;
        let mppBadge = { label: `MPP: ${mpp.toFixed(2)}`, class: 'badge-blue', icon: '‚öôÔ∏è' };
        if (mpp > 1.05) mppBadge.class = 'badge-green';
        else if (mpp < 0.95) mppBadge.class = 'badge-red';
        else mppBadge.class = 'badge-yellow';


        analysisDiv.innerHTML = `
            <div class="flex items-center mb-2 flex-wrap">
                <span class="text-lg font-semibold text-gray-800 mr-4">${subjectList[subjectCode]}</span>
                <span class="analysis-badge ${consistencyBadge.class}">${consistencyBadge.icon} Consistance E/C: ${overallConsistency.toFixed(0)}/100</span>
                <span class="analysis-badge ${volatilityBadge.class}">${volatilityBadge.icon} ${volatilityBadge.label}</span>
                ${etapeKey !== 'etape1' ? `<span class="analysis-badge ${trendBadge.class} mt-2 md:mt-0">${trendBadge.icon} Tendance: ${trendBadge.label}</span>` : ''}
                <span class="analysis-badge ${mppBadge.class} mt-2 md:mt-0">${mppBadge.icon} Multiplicateur Pr√©dit (MPP): x${mpp.toFixed(2)}</span>
            </div>
            <p class="text-sm text-gray-700 mt-2">MPP (Multiplicateur de Performance Pr√©dite) = Facteur Dynamique pour la simulation E3.</p>
        `;

        return analysisDiv;
    }

    function renderMismatchAnalysis(analysis) {
        const container = document.getElementById('mismatch-analysis');
        if (!container) return;

        let mismatchHtml = '';
        Object.entries(analysis.predictions.subjects).forEach(([code, subjPred]) => {
            const subjName = subjectList[code] || code;
            const consistency = subjPred.consistency;
            const stdDev = subjPred.stdDev;
            const mpp = subjPred.mpp;
            
            // Mismatch Score: High volatility (high stdDev) + low consistency (low score) = high mismatch
            const mismatch = (stdDev * 1.5) + (100 - consistency) / 2;
            
            let color = 'border-blue-500';
            let summary = '√âquilibre correct. Volatilit√© g√©r√©e par la bonne consistance.';

            if (mismatch > 25) {
                color = 'border-red-500';
                summary = '‚ùå **Mismatch Critique**. Votre effort (consistance faible) est annul√© par la forte volatilit√© (√©cart-type). Le risque est maximum, le MPP est p√©nalis√©.';
            } else if (mismatch > 15) {
                color = 'border-yellow-500';
                summary = '‚ö†Ô∏è **Mismatch Mod√©r√©**. Il y a un √©cart entre l\'effort et la stabilit√©. Mati√®re √† risque d\'impr√©vu.';
            } else if (mismatch < 5) {
                color = 'border-green-500';
                summary = '‚úÖ **Excellent Alignement**. Faible volatilit√© et haute consistance. Stabilit√© assur√©e.';
            }

            mismatchHtml += `
                <div class="p-3 rounded-lg border-l-4 ${color} bg-white shadow-sm">
                    <div class="flex justify-between items-center text-gray-800">
                        <strong class="text-lg">${subjName}</strong>
                        <span class="text-sm font-semibold">Score Mismatch: ${mismatch.toFixed(1)}</span>
                    </div>
                    <p class="text-sm text-gray-600 mt-1">${summary}</p>
                    <p class="text-xs text-gray-500 mt-1">Consistance: ${consistency.toFixed(0)}/100 | √âcart-type: ${stdDev.toFixed(1)}% | MPP: x${mpp.toFixed(2)}</p>
                </div>
            `;
        });

        container.innerHTML = mismatchHtml;
    }


    function renderSidePanel(analysis) {
        const formatAvg = (avg) => avg !== null ? `<span class="grade-percentage">${avg.toFixed(2)}%</span>` : '--';
        
        // Prediction (MC Trend) in the sidebar
        const mcTrend = analysis.predictions.global?.trend;
        document.getElementById('moyenne-prediction').innerHTML = formatAvg(mcTrend);
        
        document.getElementById('active-etape-name').textContent = activeTab.replace('etape', '');
        
        const subjectListEl = document.getElementById('subject-averages-list');
        subjectListEl.innerHTML = '';
        const activeTermSubjects = analysis.subjectAverages[activeTab];
        
        // Display current term averages (if data exists)
        if (activeTermSubjects && Object.keys(activeTermSubjects).length > 0) {
            // Filter out subjects with null average (no data for the current term)
            const listItems = Object.entries(activeTermSubjects)
                .filter(([code, subj]) => subj.average !== null)
                .map(([code, subj]) => {
                    return `<li class="flex justify-between"><span>${subj.name}</span><strong>${formatAvg(subj.average)}</strong></li>`;
                })
                .join('');
            
            subjectListEl.innerHTML = listItems || '<li class="no-data text-gray-500">Aucune moyenne calcul√©e pour cette √©tape</li>';
        } else {
            subjectListEl.innerHTML = '<li class="no-data text-gray-500">Aucune mati√®re pour cette √©tape</li>';
        }
    }

    function renderDeepAnalysis(analysis) {
        const { globalConsistencyScore, burnoutRiskScore } = analysis;
        
        // 1. Consistency
        const consistencyEl = document.getElementById('consistency-score');
        if (consistencyEl) {
            consistencyEl.className = 'score-card';
            consistencyEl.querySelector('strong').textContent = globalConsistencyScore.toFixed(0) + ' / 100';
            if (globalConsistencyScore < 70) consistencyEl.classList.add('card-red');
            else if (globalConsistencyScore < 90) consistencyEl.classList.add('card-violet');
            else consistencyEl.classList.add('card-green');
        }

        // 2. Burnout Risk (High score = high risk)
        const riskEl = document.getElementById('burnout-risk-score');
        if (riskEl) {
            riskEl.className = 'score-card';
            riskEl.querySelector('strong').textContent = burnoutRiskScore.toFixed(0) + ' / 100';
            if (burnoutRiskScore > 70) riskEl.classList.add('card-red');
            else if (burnoutRiskScore > 40) riskEl.classList.add('card-yellow');
            else riskEl.classList.add('card-green');
            
            riskEl.querySelector('p').textContent = `Score de Risque de Burnout (100 = Risque Maximal) - ${getBurnoutLabel(burnoutRiskScore)}`;
        }
    }

    function getBurnoutLabel(score) {
        if (score > 85) return 'Urgence: Surcharge et Volatilit√© Extr√™mes.';
        if (score > 70) return 'Tr√®s √âlev√©: Risque majeur de fatigue et notes impr√©visibles.';
        if (score > 50) return '√âlev√©: Forte charge ou Consistance √† surveiller.';
        if (score > 30) return 'Mod√©r√©: Charge g√©rable mais l√©g√®re baisse de performance.';
        return 'Faible: Stabilit√© et Effort bien g√©r√©s.';
    }

    function renderMonteCarlo(analysis) {
        const { globalAverage, globalStdDev, predictions } = analysis;
        const globalPredEl = document.getElementById('global-predictions');
        const probTableEl = document.getElementById('probability-table-body');
        const subjPredEl = document.getElementById('subject-predictions-list');
        
        if (!globalPredEl || !probTableEl || !subjPredEl) return;

        // --- 1. Global Predictions (Confidence Intervals based on MC) ---
        const predictionScenarios = [
            { name: "5% Pessimiste (P5)", key: 'p5', desc: '95% de chance d\'obtenir au moins ce score.', class: 'card-red' },
            { name: "25% Tendance Basse (P25)", key: 'p25', desc: 'Limite basse du quartile de pr√©diction.', class: 'card-yellow' },
            { name: "50% M√©dian (P50)", key: 'p50', desc: 'Score m√©dian. 50% de chance d\'√™tre au-dessus.', class: 'card-violet' },
            { name: "75% Tendance Haute (P75)", key: 'p75', desc: 'Limite haute du quartile de pr√©diction.', class: 'card-violet' },
            { name: "95% Optimiste (P95)", key: 'p95', desc: '5% de chance d\'√™tre meilleur que ce score.', class: 'card-green' },
        ];
        
        globalPredEl.innerHTML = predictionScenarios.map(scenario => {
            const value = predictions.global?.[scenario.key];
            const display = value !== null ? (value > 100 ? '>100%' : `${value.toFixed(2)}%`) : '--';
            const colorClass = scenario.class;
            
            return `
                <div class="prediction-card ${colorClass}">
                    <p class="font-bold text-gray-700">${scenario.name}</p>
                    <p class="text-sm text-gray-500">${scenario.desc}</p>
                    <div class="card-score text-gray-900">${display}</div>
                </div>
            `;
        }).join('');


        // --- 2. Probability Analysis & Required Average E3 ---
        const targets = [95, 92, 90, 88, 85, 80, 75, 70, 60];
        probTableEl.innerHTML = targets.map(target => {
            const { requiredAvg, prob } = predictions.probabilityAnalysis[target];
            
            let probClass = 'prob-low';
            let effort = 'Effort Extr√™me';

            if (prob >= 90) { probClass = 'prob-high'; effort = 'Maintenir Consistance'; }
            else if (prob >= 70) { probClass = 'prob-medium'; effort = 'Effort Mod√©r√©/Cibl√©'; }
            else if (prob >= 40) { probClass = 'prob-low'; effort = 'Effort Int√©gral'; }

            let requiredAvgDisplay = requiredAvg !== null ? (requiredAvg > 100 ? 'IMPOSSIBLE (100+)' : `${requiredAvg.toFixed(2)}%`) : '--';
            if (requiredAvg !== null && requiredAvg < 60) requiredAvgDisplay = `<span class="text-green-600">FAIBLE (${requiredAvg.toFixed(2)}%)</span>`;
            else if (requiredAvg !== null && requiredAvg > 100) requiredAvgDisplay = `<span class="text-red-600">IMPOSSIBLE (100+%)</span>`;
            
            return `
                <tr class="${probClass}">
                    <td>${target}%</td>
                    <td>${requiredAvgDisplay}</td>
                    <td>${prob.toFixed(0)}%</td>
                    <td>${effort}</td>
                </tr>
            `;
        }).join('');
        
        // --- 3. Subject Predictions ---
        subjPredEl.innerHTML = Object.entries(predictions.subjects).map(([code, subjPred]) => {
            const prediction = subjPred.trend;
            
            const cardClass = prediction >= 90 ? 'card-green' : (prediction >= 80 ? 'card-violet' : 'card-red');

            return `
                <div class="prediction-card ${cardClass}">
                    <div class="flex justify-between items-center">
                        <p class="font-bold text-lg text-gray-800">${subjectList[code] || code}</p>
                        <div class="text-sm text-gray-500">
                            MPP: x${subjPred.mpp.toFixed(2)} | Consistance E/C: ${subjPred.consistency.toFixed(0)}/100
                        </div>
                    </div>
                    <p class="text-sm text-gray-500">Pr√©diction Tendancielle Stochastique Finale (R√©sultat MC)</p>
                    <div class="card-score text-gray-900">${prediction !== null ? prediction.toFixed(2) + '%' : '--'}</div>
                </div>
            `;
        }).join('');
    }

    // --- CALCULATION LOGIC ---
    function getNumericGrade(result) {
        if (!result) return null;
        const trimmed = result.trim();
        if (gradeMap[trimmed]) return gradeMap[trimmed];
        
        const percentageMatch = trimmed.match(/(\d+[,.]?\d*)\s*%/);
        if (percentageMatch) return parseFloat(percentageMatch[1].replace(',', '.'));

        const scoreMatch = trimmed.match(/(\d+[,.]?\d*)\s*\/\s*(\d+[,.]?\d*)/);
        if (scoreMatch) {
            const score = parseFloat(scoreMatch[1].replace(',', '.'));
            const max = parseFloat(scoreMatch[2].replace(',', '.'));
            return (max > 0) ? (score / max) * 100 : null;
        }
        return null;
    }
    
    function getUnits() {
        const { niveau, unitesMode, customUnites } = mbsData.settings || {};
        if (unitesMode === 'sans') return new Proxy({}, { get: () => 1 });
        if (unitesMode === 'perso') return customUnites || {};
        return (niveau && defaultUnits[niveau]) ? defaultUnits[niveau] : {};
    }
    
    function calculateAndCacheAnalysis() {
        cachedAnalysis = calculateAllAnalysis();
    }

    function calculateSubjectAverageAndStats(subject, etapeKey, subjectIndex) {
        let totalWeightedGrade = 0;
        let totalCompetencyWeight = 0;
        let allGrades = [];
        let competencyAverages = [];

        subject.competencies.forEach((comp, compIndex) => {
            const compWeightMatch = comp.name.match(/\((\d+)%\)/);
            const compWeight = compWeightMatch ? parseFloat(compWeightMatch[1]) : 0;
            if (compWeight === 0) return;

            let compGrades = [];
            let totalAssignmentGrade = 0;
            let totalAssignmentWeight = 0;

            comp.assignments.forEach(assign => {
                const grade = getNumericGrade(assign.result);
                let weight = parseFloat(assign.pond || 0);

                if (grade !== null && !isNaN(grade) && !isNaN(weight) && weight > 0) {
                    allGrades.push(grade);
                    compGrades.push(grade);
                    totalAssignmentGrade += grade * weight;
                    totalAssignmentWeight += weight;
                }
            });

            let compAvg = null;
            let compConsistency = null;
            if (totalAssignmentWeight > 0) {
                compAvg = totalAssignmentGrade / totalAssignmentWeight;
                totalWeightedGrade += compAvg * (compWeight / 100);
                totalCompetencyWeight += (compWeight / 100);
            }
            if (compGrades.length >= 2) {
                compConsistency = calculateConsistencyScore(compGrades);
            }

            competencyAverages.push({ avg: compAvg, consistency: compConsistency, compWeight });
        });

        const subjectAverage = totalCompetencyWeight > 0 ? (totalWeightedGrade / totalCompetencyWeight) : null;
        const overallConsistency = allGrades.length >= 2 ? calculateConsistencyScore(allGrades) : 100;
        const stdDev = allGrades.length >= 2 ? calculateStdDev(allGrades) : 0;
        
        return { subjectAverage, allGrades, overallConsistency, stdDev, competencyAverages };
    }

    function calculateConsistencyScore(grades) {
        const stdDev = calculateStdDev(grades);
        // Consistency is inversely proportional to volatility (StdDev * 2 is a heuristic penalty)
        return Math.max(0, 100 - (stdDev * 2));
    }
    
    function calculateStdDev(grades) {
        if (grades.length < 2) return 0;
        const mean = grades.reduce((a, b) => a + b) / grades.length;
        const variance = grades.reduce((sum, grade) => sum + Math.pow(grade - mean, 2), 0) / grades.length;
        return Math.sqrt(variance);
    }
    
    function calculateAllAnalysis() {
        const units = getUnits();
        const niveau = mbsData.settings?.niveau;
        let allTermAverages = { etape1: null, etape2: null, etape3: null };
        let allSubjectAverages = {};
        let allSubjectStats = {}; // { code: { etape: { stats } } }
        let allSubjectOverallStats = {}; // { code: { allGrades, stdDev, overallConsistency } }
        let allGradesGlobal = [];
        
        const knownEtapeKeys = ['etape1', 'etape2']; // Only these are considered 'known' data

        // 1. Calculate Averages and Stats per Subject/Etape
        knownEtapeKeys.forEach(etape => {
            if (!mbsData[etape]) return;
            allSubjectAverages[etape] = {};

            mbsData[etape].forEach((subject, subjectIndex) => {
                const codePrefix = subject.code.substring(0, 3);
                
                const { subjectAverage, allGrades, overallConsistency, stdDev, competencyAverages } = 
                    calculateSubjectAverageAndStats(subject, etape, subjectIndex);

                allGradesGlobal.push(...allGrades);
                
                // Store subject average
                allSubjectAverages[etape][codePrefix] = { name: subjectList[codePrefix] || subject.name, average: subjectAverage };
                
                // Store subject stats
                allSubjectStats[codePrefix] = allSubjectStats[codePrefix] || {};
                allSubjectStats[codePrefix][etape] = { overallConsistency, stdDev, competencyAverages, allGrades };
            });
        });

        // 1.5 Calculate Overall Subject Stats (across all known terms)
        Object.keys(allSubjectStats).forEach(code => {
            let grades = [];
            let consistencies = [];
            knownEtapeKeys.forEach(etape => {
                if (allSubjectStats[code][etape]) {
                    grades.push(...allSubjectStats[code][etape].allGrades);
                    consistencies.push(allSubjectStats[code][etape].overallConsistency);
                }
            });
            const overallStdDev = calculateStdDev(grades);
            const overallConsistency = consistencies.length > 0 ? consistencies.reduce((a, b) => a + b) / consistencies.length : 100;
            
            allSubjectOverallStats[code] = { allGrades: grades, stdDev: overallStdDev, overallConsistency };
        });

        // 2. Calculate Term Averages and Global Averages (Only Known Terms)
        let globalWeightedSum = 0;
        let totalKnownWeight = 0;
        
        knownEtapeKeys.forEach(etape => {
            let termWeightedSum = 0;
            let termUnitSum = 0;
            
            Object.keys(allSubjectAverages[etape] || {}).forEach(codePrefix => {
                const avg = allSubjectAverages[etape][codePrefix].average;
                if (avg !== null && niveau) {
                    const unit = units[codePrefix] || 2;
                    termWeightedSum += avg * unit;
                    termUnitSum += unit;
                }
            });
            
            allTermAverages[etape] = termUnitSum > 0 ? termWeightedSum / termUnitSum : null;

            if (allTermAverages[etape] !== null) {
                globalWeightedSum += allTermAverages[etape] * TERM_WEIGHTS[etape];
                totalKnownWeight += TERM_WEIGHTS[etape];
            }
        });

        // Global Average is calculated ONLY on known terms (E1 + E2)
        const globalAverageKnown = totalKnownWeight > 0 ? globalWeightedSum / totalKnownWeight : null;

        // 3. Calculate Global Statistics
        let globalStdDev = allGradesGlobal.length >= 2 ? calculateStdDev(allGradesGlobal) : 0;
        let globalConsistencyScore = allGradesGlobal.length >= 2 ? calculateConsistencyScore(allGradesGlobal) : 100;


        // 4. Subject Trends
        let subjectTrends = {};
        Object.keys(allSubjectStats).forEach(code => {
            const avg1 = allSubjectAverages.etape1?.[code]?.average || null;
            const avg2 = allSubjectAverages.etape2?.[code]?.average || null;
            if (avg1 !== null && avg2 !== null) {
                subjectTrends[code] = { diff: avg2 - avg1 }; 
            }
        });
        
        // 5. Burnout Risk (High score = high risk)
        let burnoutRiskScore = calculateBurnoutRisk(niveau, allTermAverages, globalStdDev, allSubjectOverallStats, units);

        // 6. Monte Carlo Predictions
        const predictions = runMonteCarloSimulation(globalAverageKnown, allTermAverages, allSubjectAverages, subjectTrends, allSubjectOverallStats, units);


        return { 
            subjectAverages: allSubjectAverages, 
            termAverages: allTermAverages, 
            globalAverage: globalAverageKnown, 
            globalStdDev, 
            globalConsistencyScore, 
            subjectStats: allSubjectStats,
            subjectOverallStats: allSubjectOverallStats,
            subjectTrends,
            burnoutRiskScore,
            predictions
        };
    }
    
    function calculateBurnoutRisk(niveau, termAverages, globalStdDev, allSubjectOverallStats, units) {
        if (!niveau) return 0;
        
        // Component 1: Workload (Units) - Max 30 points
        let totalUnits = Object.values(units).reduce((sum, u) => sum + (u || 0), 0);
        let workloadScore = Math.min(30, (totalUnits / 30) * 30); 

        // Component 2: Global Volatility (StdDev) - Max 40 points
        let volatilityScore = Math.min(40, globalStdDev * 2.5); 

        // Component 3: Effort Mismatch (Average of all subject mismatches) - Max 30 points
        let totalMismatch = 0;
        let count = 0;
        Object.values(allSubjectOverallStats).forEach(s => {
            if (s.stdDev > 0) { 
                const mismatch = (s.stdDev * 1.5) + (100 - s.overallConsistency) / 2;
                totalMismatch += mismatch;
                count++; 
            }
        });
        let mismatchScore = count > 0 ? Math.min(30, (totalMismatch / count) * 1.5) : 0; // Normalize and cap at 30

        return Math.min(100, workloadScore + volatilityScore + mismatchScore);
    }
    
    // --- MONTE CARLO CORE LOGIC ---
    function runMonteCarloSimulation(globalAverageKnown, termAverages, subjectAverages, subjectTrends, subjectOverallStats, units) {
        const globalPred = { p5: null, p25: null, p50: null, p75: null, p95: null };
        const subjectPreds = {};
        const targets = [95, 92, 90, 88, 85, 80, 75, 70, 60];
        const probabilityAnalysis = {};
        
        const avg1 = termAverages.etape1;
        const avg2 = termAverages.etape2;

        let currentKnownGlobalSum = 0;
        let totalKnownWeight = 0;
        
        // Only include terms that have data in the Known Sum
        if (avg1 !== null) {
            currentKnownGlobalSum += avg1 * TERM_WEIGHTS.etape1;
            totalKnownWeight += TERM_WEIGHTS.etape1;
        }
        if (avg2 !== null) {
            currentKnownGlobalSum += avg2 * TERM_WEIGHTS.etape2;
            totalKnownWeight += TERM_WEIGHTS.etape2;
        }
        
        const totalWeight = TERM_WEIGHTS.etape1 + TERM_WEIGHTS.etape2 + TERM_WEIGHTS.etape3;
        const remainingWeight = totalWeight - totalKnownWeight;

        // If no remaining weight, prediction is the known average
        if (remainingWeight <= 0) {
             globalPred.p5 = globalPred.p25 = globalPred.p50 = globalPred.p75 = globalPred.p95 = globalAverageKnown;
             targets.forEach(t => {
                probabilityAnalysis[t] = { requiredAvg: null, prob: globalAverageKnown >= t ? 100 : 0 };
             });
             return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
        }
        
        // Identify subjects relevant for E3 prediction (those with units and at least one known term average)
        const relevantSubjects = Object.keys(subjectOverallStats).filter(code => units[code] && (subjectAverages.etape1?.[code] || subjectAverages.etape2?.[code]));
        
        if (relevantSubjects.length === 0) {
            targets.forEach(t => { probabilityAnalysis[t] = { requiredAvg: 0, prob: 100 }; }); // Optimistic assumption if no data available
            return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
        }

        // --- 1. Required Average for Etape 3 (Deterministic) ---
        targets.forEach(target => {
            const requiredAvg = (target * totalWeight - currentKnownGlobalSum) / remainingWeight;
            
            // Simplified probability (based on Z-Score, using best current avg as proxy)
            const currentTrendAvg = avg2 !== null ? avg2 : (avg1 !== null ? avg1 : 75); // Use 75 as baseline if no term data
            const stdDevProxy = subjectOverallStats && Object.values(subjectOverallStats).length > 0 ? 
                                Object.values(subjectOverallStats).reduce((sum, s) => sum + s.stdDev, 0) / Object.values(subjectOverallStats).length : 5;
            
            const prob = calculateProbability(currentTrendAvg, stdDevProxy, requiredAvg);

            probabilityAnalysis[target] = { requiredAvg: requiredAvg, prob: prob };
        });


        // --- 2. Monte Carlo Simulation (Stochastic) ---
        let finalGrades = [];
        let subjectSumGrades = {};

        relevantSubjects.forEach(code => subjectSumGrades[code] = 0);
        
        // Pre-calculate MPP for each subject
        relevantSubjects.forEach(code => {
            const subjStats = subjectOverallStats[code];
            const trend = subjectTrends[code];

            let trendAvg = subjectAverages.etape2?.[code]?.average || subjectAverages.etape1?.[code]?.average || 75; // Baseline

            // T1: Trend Adjustment (up to +/- 5%)
            let trendAdjustment = trend?.diff ? Math.min(5, Math.max(-5, trend.diff)) * 0.5 : 0; // max 5% diff affects mean by 2.5%

            // T2: Consistency Adjustment (up to +/- 5%)
            // Reward stability (Consist > 90) or penalize instability (Consist < 70)
            let consistencyAdjustment = 0;
            if (subjStats.overallConsistency >= 90) consistencyAdjustment = 2.5; // Reward
            else if (subjStats.overallConsistency < 70) consistencyAdjustment = -2.5; // Penalize

            // T3: Volatility Multiplier (affects spread, not mean, handled later)
            const consistencyFactor = Math.max(0.1, 1 - (subjStats.overallConsistency / 100));
            
            // Final Mean Multiplier (MPP)
            const mpp = Math.min(1.10, Math.max(0.90, 1 + (trendAdjustment + consistencyAdjustment) / 100)); // Cap MPP between 0.90 and 1.10
            
            subjectPreds[code] = { 
                mpp: mpp,
                stdDev: subjStats.stdDev,
                consistency: subjStats.overallConsistency,
                trend: 0, // Placeholder for final MC avg
                consistencyFactor: consistencyFactor // Used for spreading SD
            };
        });


        // Run N simulations
        for (let i = 0; i < NUM_MONTE_CARLO_RUNS; i++) {
            let simKnownSum = currentKnownGlobalSum;
            let simRemainingSum = 0;
            let simTotalUnitWeight = 0;
            
            relevantSubjects.forEach(code => {
                const subjPred = subjectPreds[code];
                const subjAvg1 = subjectAverages.etape1?.[code]?.average || null;
                const subjAvg2 = subjectAverages.etape2?.[code]?.average || null;
                const unit = units[code] || 2;
                
                let trendAvg = subjAvg2 !== null ? subjAvg2 : (subjAvg1 !== null ? subjAvg1 : 75);
                let stdDev = subjPred.stdDev;
                
                // Adjust Mean by MPP
                const adjustedMean = trendAvg * subjPred.mpp;

                // Adjust Volatility (SD) based on low consistency (high risk = higher SD for prediction)
                stdDev = stdDev * (1 + subjPred.consistencyFactor * 0.5); 

                // Generate a random grade for E3 using Box-Muller (Normal Distribution)
                const u1 = Math.random();
                const u2 = Math.random();
                let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                let predictedE3Avg = Math.min(100, Math.max(0, adjustedMean + z * stdDev));

                // Calculate final grade for subject in this simulation: (E1+E2 + E3) / Total
                let subjKnownSum = 0;
                if (subjAvg1 !== null) subjKnownSum += subjAvg1 * TERM_WEIGHTS.etape1;
                if (subjAvg2 !== null) subjKnownSum += subjAvg2 * TERM_WEIGHTS.etape2;
                
                const simSubjFinalGrade = (subjKnownSum + predictedE3Avg * TERM_WEIGHTS.etape3) / totalWeight;
                
                subjectSumGrades[code] += simSubjFinalGrade;
                
                // Global Calculation
                simRemainingSum += predictedE3Avg * unit;
                simTotalUnitWeight += unit;
            });
            
            const predictedE3AvgGlobal = simTotalUnitWeight > 0 ? simRemainingSum / simTotalUnitWeight : 0;
            const finalGlobalGrade = (currentKnownGlobalSum + predictedE3AvgGlobal * remainingWeight) / totalWeight;
            
            finalGrades.push(finalGlobalGrade);
        }

        // --- 3. Final Monte Carlo Results (Percentiles) ---
        finalGrades.sort((a, b) => a - b);

        globalPred.p5 = finalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.05)] || 0;
        globalPred.p25 = finalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.25)] || 0;
        globalPred.p50 = finalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.50)] || 0;
        globalPred.p75 = finalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.75)] || 0;
        globalPred.p95 = finalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.95)] || 0;
        globalPred.trend = finalGrades.reduce((a, b) => a + b) / NUM_MONTE_CARLO_RUNS; // Actual Mean

        const mcStdDev = calculateStdDev(finalGrades);

        // Subject Final Predictions
        relevantSubjects.forEach(code => {
            // Update the trend (actual MC average)
            subjectPreds[code].trend = subjectSumGrades[code] / NUM_MONTE_CARLO_RUNS;
        });
        
        // Re-evaluate probability based on MC trend and its own SD
        targets.forEach(target => {
            const prob = calculateProbability(globalPred.trend, mcStdDev, probabilityAnalysis[target].requiredAvg);
            probabilityAnalysis[target].prob = prob;
        });


        return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
    }

    // Approx. Probability based on Z-Score (CDF)
    function calculateProbability(mean, stdDev, requiredTarget) {
        if (mean === null) return 0;
        if (stdDev <= 0.1) return mean >= requiredTarget ? 100 : 0; // Near deterministic case
        
        // If the required target is impossible (above 100 or below 0), probability is 0
        if (requiredTarget > 100) return 0;
        if (requiredTarget < 60 && mean < 60) return 100; // If already failing and target is low, high chance to meet low bar

        const z = (requiredTarget - mean) / stdDev;

        // Quick approximation of CDF (Inverse of probability of NOT meeting the target)
        // This estimates the area of the curve *below* the target, we want the area *above* (1 - CDF)
        // Approximating 1-CDF(z)
        if (z < -3.0) return 99; 
        if (z < -2.5) return 98;
        if (z < -2.0) return 95; 
        if (z < -1.5) return 93; 
        if (z < -1.0) return 84; 
        if (z < -0.5) return 69; 
        if (z < 0.0) return 50;  
        if (z < 0.5) return 31;
        if (z < 1.0) return 16;
        if (z < 1.5) return 7;
        if (z < 2.0) return 5;
        if (z < 2.5) return 2;
        return 1; 
    }


    // --- EVENT LISTENERS ---
    function setupEventListeners() {
        // Tabs
        document.querySelectorAll('.tab-btn').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelector('.tab-btn.active')?.classList.remove('active');
                tab.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                activeTab = tab.dataset.tab;
                document.getElementById(activeTab)?.classList.add('active');
                
                renderSidePanel(cachedAnalysis);
            });
        });

        // Settings
        document.getElementById('niveau-secondaire')?.addEventListener('change', saveSettings);
        document.getElementById('unites-mode')?.addEventListener('change', () => {
            saveSettings();
            populateUnitesModal();
        });

        // Modals
        const unitesModal = document.getElementById('unites-modal');
        document.getElementById('unites-btn')?.addEventListener('click', () => {
            populateUnitesModal();
            unitesModal?.classList.add('active');
        });
        document.getElementById('close-unites-modal')?.addEventListener('click', () => {
            saveCustomUnits();
            unitesModal?.classList.remove('active');
        });
    }
    
    function populateUnitesModal() {
        const unitesListEl = document.getElementById('unites-list');
        if (!unitesListEl) return;
        
        unitesListEl.innerHTML = '';

        const currentUnits = getUnits();
        const subjectCodes = new Set();

        // Collect all unique subject codes present in data
        ['etape1', 'etape2', 'etape3'].forEach(etapeKey => {
            mbsData[etapeKey]?.forEach(subject => {
                const codePrefix = subject.code.substring(0, 3);
                subjectCodes.add(codePrefix);
            });
        });

        Array.from(subjectCodes).sort().forEach(code => {
            // Use the current unit or 2 as a default, especially if data is missing for this subject
            const currentUnitValue = currentUnits[code] || 2; 
            const li = document.createElement('div');
            li.className = 'unite-item flex justify-between items-center border-b border-gray-200 py-2';
            li.innerHTML = `
                <span class="text-gray-700">${subjectList[code] || code} (${code})</span>
                <input type="number" class="w-20 text-right p-1 border rounded-md" value="${currentUnitValue}" min="0" max="10" data-code="${code}" onchange="saveCustomUnits()">
            `;
            unitesListEl.appendChild(li);
        });
        // Attach event listener for inputs inside the modal
        window.saveCustomUnits = saveCustomUnits;
    }

    // --- START THE APP ---
    init();
});
    </script>
</body>
</html>

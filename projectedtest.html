<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projections d'Averages Dynamiques</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        h2, h3 {
            color: #007bff;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-top: 20px;
        }
        .current-average-box {
            background-color: #e9f7ff;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 20px;
        }
        .grade-percentage {
            font-weight: bold;
            color: #28a745;
            font-size: 1.5em;
        }
        .projection-list {
            list-style: none;
            padding: 0;
        }
        .projection-list li {
            background-color: #f9f9f9;
            margin-bottom: 10px;
            padding: 15px;
            border-radius: 4px;
            border-left: 5px solid #007bff;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
        }
        .projection-list li span.category-name {
            font-weight: bold;
            flex-basis: 50%;
        }
        .projection-list li span.projected-avg {
            font-size: 1.2em;
            color: #dc3545;
            flex-basis: 20%;
            text-align: right;
        }
        .projection-list li p.projection-desc {
            font-size: 0.9em;
            color: #6c757d;
            margin: 5px 0 0 0;
            flex-basis: 100%;
        }
        .no-data {
            color: #ffc107;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Analyse et Projection des Performances Scolaires</h1>
        
        <div id="projection-results">
            <p style="text-align: center;">Chargement des données de projection...</p>
        </div>
        
        <p style="text-align: center; margin-top: 30px; font-size: 0.8em; color: #999;">
            Note: Les résultats dépendent des données stockées dans le Local Storage de votre navigateur.
        </p>
    </div>

    <script >

// --- CONSTANTS ---
const gradeMap = { 'A+': 100, 'A': 95, 'A-': 90, 'B+': 85, 'B': 80, 'B-': 75, 'C+': 70, 'C-': 60, 'D+': 55, 'D': 50, 'E': 45 };
const defaultUnits = {
    sec4: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'FRA': 6, 'ELA': 4, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 6, 'ST': 4, 'STE': 4, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'ENT': 2, 'INF': 2, 'PSY': 2 },
    sec5: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'CAT': 4, 'FRA': 6, 'ELA': 6, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 4, 'MED': 4, 'PSY': 4, 'ENT': 4, 'FIN': 4, 'CHI': 4, 'PHY': 4, 'MON': 2, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'FIN': 2 }
};
const subjectList = { 'ART': "Arts Plastiques", 'MUS': "Musique", 'DRM': "Art Dramatique", 'CAT': "Conception et Application Technologique", 'FRA': "Français", 'ELA': "English Language Arts", 'EESL': "Enriched English", 'ESL': "English Second Language", 'SN': "Math SN", 'CST': "Math CST", 'ST': "Science et Technologie", 'STE': "Science et Tech. Env.", 'HQC': "Histoire", 'CCQ': "Culture et Citoyenneté", 'EPS': "Éducation Physique", 'CHI': "Chimie", 'PHY': "Physique", 'MON': "Monde Contemporain", 'MED': "Média", 'ENT': "Entrepreneuriat", 'INF': "Informatique", 'PSY': "Psychologie", 'FIN': "Éducation Financière" };
const termWeights = { etape1: 0.20, etape2: 0.20, etape3: 0.60 };

let mbsData = {}; // Assumed to be populated before calling calculation functions

// --- UTILITY FUNCTIONS ---

function getNumericGrade(result) {
    if (!result) return null;
    const trimmed = result.trim();
    if (gradeMap[trimmed]) return gradeMap[trimmed];
    const percentageMatch = trimmed.match(/(\d+[,.]?\d*)\s*%/);
    if (percentageMatch) return parseFloat(percentageMatch[1].replace(',', '.'));
    const scoreMatch = trimmed.match(/(\d+[,.]?\d*)\s*\/\s*(\d+[,.]?\d*)/);
    if (scoreMatch) {
        const score = parseFloat(scoreMatch[1].replace(',', '.'));
        const max = parseFloat(scoreMatch[2].replace(',', '.'));
        return (max > 0) ? (score / max) * 100 : null;
    }
    return null;
}

function getUnits() {
    const { niveau, unitesMode, customUnites } = mbsData.settings || {};
    if (unitesMode === 'sans') return new Proxy({}, { get: () => 1 });
    if (unitesMode === 'perso') return customUnites || {};
    const niveauKey = mbsData.settings?.niveau;
    return (niveauKey && defaultUnits[niveauKey]) ? defaultUnits[niveauKey] : {};
}

function calculateSubjectAverage(subject, projectionGradeFunc = null) {
    let totalWeightedGrade = 0;
    let totalCompetencyWeight = 0;

    subject.competencies.forEach(comp => {
        const compWeightMatch = comp.name.match(/\((\d+)%\)/);
        if (!compWeightMatch) return;
        const compWeight = parseFloat(compWeightMatch[1]);

        let totalAssignmentGrade = 0;
        let totalAssignmentWeight = 0;

        comp.assignments.forEach(assign => {
            let grade = getNumericGrade(assign.result);
            let weight = parseFloat(assign.pond) || 1; 

            if (grade !== null && !isNaN(weight) && weight > 0) {
                totalAssignmentGrade += grade * weight;
                totalAssignmentWeight += weight;
            } else if (projectionGradeFunc) {
                let projectedGrade = projectionGradeFunc(subject, comp, assign);
                
                if (projectedGrade !== null && !isNaN(projectedGrade)) {
                    totalAssignmentGrade += projectedGrade * weight;
                    totalAssignmentWeight += weight;
                }
            }
        });

        if (totalAssignmentWeight > 0) {
            const competencyAverage = totalAssignmentGrade / totalAssignmentWeight;
            totalWeightedGrade += competencyAverage * compWeight;
            totalCompetencyWeight += compWeight;
        }
    });

    return totalCompetencyWeight > 0 ? totalWeightedGrade / totalCompetencyWeight : null;
}

function calculateTermAverage(termData, units, projectionGradeFunc = null) {
    if (!termData) return { average: null, subjects: {} };
    let termWeightedSum = 0;
    let termUnitSum = 0;
    let subjectAverages = {};

    termData.forEach(subject => {
        const average = calculateSubjectAverage(subject, projectionGradeFunc);
        const codePrefix = subject.code.substring(0, 3);
        
        if (average !== null) {
            const unit = units[codePrefix] || 2;
            termWeightedSum += average * unit;
            termUnitSum += unit;
        }
        subjectAverages[codePrefix] = { name: subjectList[codePrefix] || subject.name, average };
    });

    const termAverage = termUnitSum > 0 ? termWeightedSum / termUnitSum : null;
    return { average: termAverage, subjects: subjectAverages };
}

// --- STEP 1: TREND AND STABILITY ANALYSIS ---

function analyzeSubjectTrend(codePrefix, data) {
    let grades = [];
    let competencyGrades = {};

    ['etape1', 'etape2', 'etape3'].forEach(etape => {
        if (data[etape]) {
            data[etape].filter(s => s.code.startsWith(codePrefix)).forEach(subject => {
                subject.competencies.forEach(comp => {
                    const compName = comp.name.split('(')[0].trim();
                    if (!competencyGrades[compName]) competencyGrades[compName] = [];

                    comp.assignments.forEach(assign => {
                        const grade = getNumericGrade(assign.result);
                        if (grade !== null) {
                            grades.push(grade);
                            competencyGrades[compName].push(grade);
                        }
                    });
                });
            });
        }
    });

    if (grades.length === 0) return { mean: null, stdDev: 0, competencyMeans: {}, bestCompMean: null, currentAvg: null };

    // 1. Calculate Exponentially Weighted Mean (Prioritizes recent grades)
    const lambda = 0.9; 
    let weightedSum = 0;
    let totalWeight = 0;
    
    grades.slice().reverse().forEach((g, index) => { 
        const weight = Math.pow(lambda, index); 
        weightedSum += g * weight;
        totalWeight += weight;
    });

    const mean = totalWeight > 0 ? weightedSum / totalWeight : grades.reduce((sum, g) => sum + g, 0) / grades.length;
    
    // 2. Calculate Standard Deviation (Instability)
    const variance = grades.reduce((sum, g) => sum + Math.pow(g - mean, 2), 0) / grades.length;
    const stdDev = Math.sqrt(variance);

    // 3. Calculate Competency Means and find the best one
    let bestCompMean = 0;
    const competencyMeans = Object.entries(competencyGrades).reduce((acc, [name, g]) => {
        const compMean = g.length > 0 ? g.reduce((sum, gr) => sum + gr, 0) / g.length : mean;
        acc[name] = compMean;
        bestCompMean = Math.max(bestCompMean, compMean);
        return acc;
    }, {});
    
    // 4. Calculate Current Average (Last available term for this subject)
    let currentAvg = null;
    for (const etape of ['etape3', 'etape2', 'etape1']) {
        const termData = data[etape];
        if (termData) {
            const subject = termData.find(s => s.code.startsWith(codePrefix));
            if (subject) {
                currentAvg = calculateSubjectAverage(subject);
                if (currentAvg !== null) break;
            }
        }
    }

    return { mean, stdDev, competencyMeans, bestCompMean, currentAvg };
}

// --- STEP 2: SCENARIO DEFINITION ---

function getScenarioParameters(gpi, allSubjectTrends) {
    const trendValues = Object.values(allSubjectTrends);
    const subjectCount = trendValues.length;
    let globalStdDev = 0;
    
    if (subjectCount > 0) {
        const sumStdDev = trendValues.filter(t => t.stdDev > 0)
            .map(t => t.stdDev)
            .reduce((a, b) => a + b, 0);
        
        globalStdDev = sumStdDev / subjectCount;
    }

    const gpiClean = gpi !== null ? gpi : 75;
    
    const baseAdj = (gpiClean > 90) ? 0 : (gpiClean > 80) ? 1 : (gpiClean > 70) ? 3 : 5;
    const pessimismFactor = Math.min(10, 5 + globalStdDev * 0.5);

    return {
        'Theoretical Limit': { description: "100% sur tous les travaux futurs. Limite absolue.", factor: 1.0, gradeFloor: 100, trendStrategy: 'flat' },
        'Optimistic Trend': { 
            description: "Amélioration progressive, basée sur la meilleure performance des compétences.", 
            factor: 1.05, 
            gradeFloor: gpiClean + 2 + baseAdj,
            trendStrategy: 'bestComp' 
        },
        'Realistic Trend': { 
            description: "Maintien de la tendance pondérée récente (moyenne ajustée par la volatilité).", 
            factor: 1.0, 
            gradeFloor: gpiClean + (globalStdDev > 10 ? 0 : baseAdj),
            trendStrategy: 'weightedMean'
        },
        'Competency Focus': {
            description: "Focus sur la compétence la plus forte (projeté à la moyenne de cette compétence).",
            factor: 1.0,
            gradeFloor: gpiClean,
            trendStrategy: 'bestComp'
        },
         'Minimal Effort': {
            description: "Projeté à la note de passage minimale ajustée par la volatilité passée.",
            factor: 0.95,
            gradeFloor: Math.max(50, gpiClean - pessimismFactor),
            trendStrategy: 'lowest'
        }
    };
}

// --- STEP 3: PROJECTION FUNCTION ---

function generateProjectionGrade(subject, comp, scenario, allSubjectTrends) {
    const codePrefix = subject.code.substring(0, 3);
    const trend = allSubjectTrends[codePrefix];
    
    let baseGrade = scenario.gradeFloor;

    if (trend && trend.mean !== null) {
        switch (scenario.trendStrategy) {
            case 'flat':
                baseGrade = 100;
                break;
            case 'weightedMean':
                baseGrade = trend.mean; 
                baseGrade = baseGrade + (trend.stdDev < 5 ? 1 : 0); 
                break;
            case 'bestComp':
                baseGrade = trend.bestCompMean; 
                break;
             case 'lowest':
                baseGrade = Math.max(55, trend.mean - trend.stdDev);
                break;
        }
    }
    
    let projectedGrade = baseGrade * scenario.factor;
    
    projectedGrade = Math.min(100, Math.max(50, projectedGrade)); 

    return projectedGrade;
}

// --- MAIN ORCHESTRATOR ---

function calculateAllProjections(data) {
    const units = getUnits();
    
    // 1. Calculate BASE AVERAGES and gather all Subject Codes
    const { allTermAverages, allSubjects } = ['etape1', 'etape2', 'etape3'].reduce((acc, etape) => {
        const result = calculateTermAverage(data[etape], units);
        acc.allTermAverages[etape] = result.average;
        if (data[etape]) data[etape].forEach(s => acc.allSubjects[s.code.substring(0, 3)] = true);
        return acc;
    }, { allTermAverages: {}, allSubjects: {} });

    let currentGlobalWeightedSum = 0;
    let totalWeight = 0;
    Object.entries(allTermAverages).forEach(([etape, avg]) => {
        if (avg !== null) {
            currentGlobalWeightedSum += avg * termWeights[etape];
            totalWeight += termWeights[etape];
        }
    });
    const gpi = totalWeight > 0 ? currentGlobalWeightedSum / totalWeight : null;

    // 2. Trend Analysis for all subjects
    const allSubjectTrends = Object.keys(allSubjects).reduce((acc, code) => {
        acc[code] = analyzeSubjectTrend(code, data);
        return acc;
    }, {});
    
    // 3. Define Scenarios and calculate Subject Projections
    const scenarios = getScenarioParameters(gpi, allSubjectTrends);
    const projectedFinalAverages = {};
    const subjectProjections = {};
    
    Object.keys(allSubjects).forEach(code => {
        subjectProjections[code] = { 
            currentAvg: allSubjectTrends[code].currentAvg, 
            trends: allSubjectTrends[code], 
            projections: {} 
        };
    });
    
    // 4. Run Projections for each Scenario (Annual and Subject)
    Object.entries(scenarios).forEach(([scenarioName, scenarioParams]) => {
        let scenarioWeightedSum = 0;
        let scenarioTotalWeight = 0;
        
        ['etape1', 'etape2', 'etape3'].forEach(etape => {
            let termAvg = allTermAverages[etape];

            const termNeedsProjection = termAvg === null || (etape === 'etape3' && totalWeight < 1);
            
            let projectedTermResult = { average: termAvg, subjects: {} };

            if (termNeedsProjection) {
                const projectionFunc = (subject, comp, assign) => generateProjectionGrade(subject, comp, scenarioParams, allSubjectTrends);
                
                projectedTermResult = calculateTermAverage(data[etape] || [], units, projectionFunc);
                termAvg = projectedTermResult.average;
            }
            
            if (scenarioName === 'Realistic Trend' && projectedTermResult.subjects) {
                 Object.entries(projectedTermResult.subjects).forEach(([code, subjectData]) => {
                     if (subjectProjections[code]) {
                        subjectProjections[code].projections[etape] = subjectData.average;
                     }
                 });
            }

            if (termAvg !== null) {
                scenarioWeightedSum += termAvg * termWeights[etape];
                scenarioTotalWeight += termWeights[etape];
            }
        });

        projectedFinalAverages[scenarioName] = scenarioTotalWeight > 0 ? scenarioWeightedSum / scenarioTotalWeight : null;
    });

    return { gpi, projectedFinalAverages, subjectProjections, allSubjectTrends };
}
    </script>
</body>
</html>

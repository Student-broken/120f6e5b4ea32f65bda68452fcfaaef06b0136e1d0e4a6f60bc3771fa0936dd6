<script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONSTANTS ---
            // These constants MUST be defined here, as the script was incorrectly trying to load them from mbsData.
            const gradeMap = { 'A+': 100, 'A': 95, 'A-': 90, 'B+': 85, 'B': 80, 'B-': 75, 'C+': 70, 'C': 65, 'C-': 60, 'D+': 55, 'D': 50, 'E': 45 };
            const subjectList = { 'ART': "Arts Plastiques", 'MUS': "Musique", 'DRM': "Art Dramatique", 'CAT': "Conception et Application Technologique", 'FRA': "Fran√ßais", 'ELA': "English Language Arts", 'EESL': "Anglais enrichi", 'ESL': "Anglais langue seconde", 'SN': "Math SN", 'CST': "Math CST", 'ST': "Science et Technologie", 'STE': "Science et Tech. Env.", 'HQC': "Histoire", 'CCQ': "Culture et Citoyennet√©", 'EPS': "√âducation Physique", 'CHI': "Chimie", 'PHY': "Physique", 'MON': "Monde Contemporain", 'MED': "M√©dia", 'ENT': "Entrepreneuriat", 'INF': "Informatique", 'PSY': "Psychologie", 'FIN': "√âducation Financi√®re" };
            const MODEL_STORAGE_PATH = 'localstorage://student-ai-model-v1';

            // --- UI Elements ---
            const trainButton = document.getElementById('train-button');
            const clearButton = document.getElementById('clear-model-button');
            const predictButton = document.getElementById('predict-button');
            const statusEl = document.getElementById('ai-status');
            const logEl = document.getElementById('training-log');
            const dataPointsEl = document.getElementById('data-points');
            const subjectSelect = document.getElementById('subject-select');
            const pondInput = document.getElementById('pond-input');
            const compInput = document.getElementById('comp-input');
            const predictionResultEl = document.getElementById('prediction-result');
            const predictionScoreEl = document.getElementById('prediction-score');
            const predictionContextEl = document.getElementById('prediction-context');

            // --- AI & Data State ---
            let allAssignments = []; // Our entire dataset
            let subjectDataMap = {}; // For tracking subject-specific data
            let tfModel = null;
            let mbsData = {};

            // --- FIX: Change "Predict" Button Text ---
            predictButton.querySelector('span').textContent = 'üìä Soumettre Donn√©es & Pr√©dire';


            // ==========================================================
            // 1. DATA EXTRACTION & PRE-PROCESSING
            // (The fix for the "Error loading data" is here)
            // ==========================================================

            /**
             * Helper function to robustly get the numeric grade.
             */
            function getNumericGrade(result) {
                if (!result) return null;
                const trimmed = result.trim().toLowerCase();
                if (trimmed === 'absent' || trimmed === 'abs' || trimmed === '0' || trimmed === '0%') return 0;
                if (trimmed === 'exempt' || trimmed === 'n/a' || trimmed === 'retard' || trimmed === 'remis' || trimmed === '') return null;
                const originalTrimmed = result.trim();
                if (gradeMap[originalTrimmed]) return gradeMap[originalTrimmed];
                const percentageMatch = trimmed.match(/(\d+[,.]?\d*)\s*%/);
                if (percentageMatch) return parseFloat(percentageMatch[1].replace(',', '.'));
                const scoreMatch = trimmed.match(/(\d+[,.]?\d*)\s*\/\s*(\d+[,.]?\d*)/);
                if (scoreMatch) {
                    const score = parseFloat(scoreMatch[1].replace(',', '.'));
                    const max = parseFloat(scoreMatch[2].replace(',', '.'));
                    return (max > 0) ? (score / max) * 100 : null;
                }
                const plainNumber = parseFloat(trimmed);
                if (!isNaN(plainNumber) && plainNumber >= 0 && plainNumber <= 110) {
                    return plainNumber;
                }
                return null; 
            }

            /**
             * Loads and extracts all assignment data.
             */
            function extractAllAssignments() {
                let flatData = [];
                let subjectCounters = {};
                let subjectsFound = new Set();
                subjectDataMap = {};

                try {
                    mbsData = JSON.parse(localStorage.getItem('mbsData')) || {};
                    
                    // Critical check: if no data or data is invalid, stop here.
                    if (!mbsData.valid) {
                        statusEl.innerHTML = '<strong class="text-red-600">Erreur au chargement des donn√©es. Assurez-vous d\'avoir des donn√©es dans le Local Storage.</strong>';
                        return;
                    }
                    
                    ['etape1', 'etape2', 'etape3'].forEach(etapeKey => {
                        if (mbsData[etapeKey]) {
                            mbsData[etapeKey].forEach(subject => {
                                const subjectCode = subject.code.substring(0, 3);
                                subjectsFound.add(subjectCode);
                                if (!subjectCounters[subjectCode]) {
                                    subjectCounters[subjectCode] = 0;
                                    subjectDataMap[subjectCode] = { time: [], compWeights: [] };
                                }

                                subject.competencies.forEach(comp => {
                                    // Robustly extract CompWeight (e.g., "Comp√©tence 1 (40%)")
                                    const compWeightMatch = comp.name.match(/\((\d+)%\)/);
                                    const compWeight = compWeightMatch ? parseFloat(compWeightMatch[1]) : 0;

                                    comp.assignments.forEach(assign => {
                                        const grade = getNumericGrade(assign.result);
                                        const pond = parseFloat(assign.pond || 0);
                                        
                                        if (grade !== null && !isNaN(grade) && pond > 0 && compWeight > 0) {
                                            const time = ++subjectCounters[subjectCode];
                                            flatData.push({
                                                time: time,       
                                                pond: pond,       
                                                compWeight: compWeight,
                                                grade: grade      
                                            });
                                            subjectDataMap[subjectCode].time.push(time);
                                            subjectDataMap[subjectCode].compWeights.push(compWeight);
                                        }
                                    });
                                });
                            });
                        }
                    });

                    allAssignments = flatData;
                    dataPointsEl.textContent = allAssignments.length;
                    
                    // Populate the dropdown with found subjects
                    subjectSelect.innerHTML = '<option value="">-- Choisir une mati√®re --</option>';
                    Array.from(subjectsFound).sort().forEach(code => {
                        const opt = document.createElement('option');
                        opt.value = code;
                        opt.textContent = subjectList[code] || code;
                        subjectSelect.appendChild(opt);
                    });


                } catch (e) {
                    console.error("Failed to load or parse mbsData:", e);
                    statusEl.innerHTML = '<strong class="text-red-600">Erreur critique dans la structure des donn√©es.</strong>';
                }
            }

            // ==========================================================
            // 2. TENSORFLOW.JS MODEL MANAGEMENT (Unchanged)
            // ==========================================================

            function createNewModel() {
                const model = tf.sequential();
                model.add(tf.layers.normalization({ inputShape: [3] }));
                model.add(tf.layers.dense({ units: 32, activation: 'relu' }));
                model.add(tf.layers.dropout({ rate: 0.1 }));
                model.add(tf.layers.dense({ units: 16, activation: 'relu' }));
                model.add(tf.layers.dense({ units: 1, activation: 'linear' }));
                model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'meanSquaredError'
                });
                logToScreen("Nouveau mod√®le IA cr√©√©.");
                return model;
            }

            async function loadOrCreateTfModel() {
                try {
                    const model = await tf.loadLayersModel(MODEL_STORAGE_PATH);
                    tfModel = model;
                    logToScreen("Mod√®le IA existant charg√© depuis le stockage local.");
                    predictButton.disabled = false;
                } catch (e) {
                    logToScreen("Aucun mod√®le trouv√©. Cr√©ation d'un nouveau mod√®le...");
                    tfModel = createNewModel();
                }
            }
            
            async function trainModel() {
                if (allAssignments.length < 20) {
                    logToScreen(`Pas assez de donn√©es (${allAssignments.length}). Minimum 20 points de donn√©es requis pour l'entra√Ænement.`);
                    return;
                }

                const { inputTensor, labelTensor } = tf.tidy(() => {
                    tf.util.shuffle(allAssignments);

                    const inputs = allAssignments.map(d => [d.time, d.pond, d.compWeight]);
                    const labels = allAssignments.map(d => d.grade);

                    const inputTensor = tf.tensor2d(inputs, [inputs.length, 3]);
                    const labelTensor = tf.tensor2d(labels, [labels.length, 1]);

                    return { inputTensor, labelTensor };
                });

                logToScreen("Adaptation de la couche de normalisation...");
                await tfModel.layers[0].adapt(inputTensor);

                logToScreen("D√©but de l'entra√Ænement... (Ceci peut prendre un moment)");
                trainButton.classList.add('loading');
                trainButton.disabled = true;

                await tfModel.fit(inputTensor, labelTensor, {
                    epochs: 50,
                    batchSize: 16,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            const valLoss = logs.val_loss.toFixed(2);
                            logToScreen(`√âpoque ${epoch + 1}/50 - Perte: ${logs.loss.toFixed(2)} - Perte Val: ${valLoss}`);
                            if (epoch === 49) {
                                logToScreen(`Entra√Ænement termin√© ! Perte finale : ${valLoss}`);
                            }
                        }
                    }
                });
                
                await tfModel.save(MODEL_STORAGE_PATH);
                logToScreen("Mod√®le intelligent sauvegard√© dans le stockage local !");
                
                trainButton.classList.remove('loading');
                trainButton.disabled = false;
                predictButton.disabled = false;

                inputTensor.dispose();
                labelTensor.dispose();
            }

            // ==========================================================
            // 3. UI & EVENT LISTENERS
            // ==========================================================

            /**
             * Renamed from runPrediction to reflect user intent to submit data.
             */
            function submitAndPredict() {
                const subjectCode = subjectSelect.value;
                const pond = parseFloat(pondInput.value);
                const compWeight = parseFloat(compInput.value);

                if (!subjectCode || isNaN(pond) || isNaN(compWeight) || !tfModel) {
                    alert("Veuillez s√©lectionner une mati√®re et entrer une pond√©ration et un poids de comp√©tence valides, et assurez-vous que le mod√®le est entra√Æn√©.");
                    return;
                }
                
                // Find the *next* time step for this subject
                const subjectTimes = subjectDataMap[subjectCode]?.time || [0];
                const nextTime = Math.max(0, ...subjectTimes) + 1;
                
                const input = tf.tensor2d([[nextTime, pond, compWeight]], [1, 3]);

                const prediction = tfModel.predict(input);
                
                prediction.data().then(data => {
                    let predictedGrade = data[0];
                    if (predictedGrade > 100) predictedGrade = 100;
                    if (predictedGrade < 40) predictedGrade = 40;
                    
                    predictionScoreEl.textContent = `${predictedGrade.toFixed(1)}%`;
                    predictionContextEl.textContent = `Pr√©diction pour ${subjectList[subjectCode] || subjectCode} (Devoir #${nextTime}, Pond: ${pond}%, Comp: ${compWeight}%)`;
                    predictionResultEl.classList.remove('hidden');
                });
                
                input.dispose();
                prediction.dispose();
            }

            function logToScreen(message) {
                console.log(message);
                logEl.textContent = message + '\n' + logEl.textContent;
            }

            // --- Attach Event Listeners ---
            trainButton.addEventListener('click', trainModel);
            predictButton.addEventListener('click', submitAndPredict);

            clearButton.addEventListener('click', async () => {
                if (confirm("Voulez-vous vraiment effacer le mod√®le IA ? L'IA devra tout r√©apprendre.")) {
                    await tf.io.removeModel(MODEL_STORAGE_PATH);
                    tfModel = createNewModel();
                    logToScreen("Mod√®le IA r√©initialis√©.");
                    predictButton.disabled = true;
                }
            });

            // --- Initialization ---
            async function init() {
                logToScreen("Initialisation de l'onglet IA...");
                extractAllAssignments();
                await loadOrCreateTfModel();
                logToScreen("Syst√®me pr√™t.");
            }

            init();
        });
    </script>

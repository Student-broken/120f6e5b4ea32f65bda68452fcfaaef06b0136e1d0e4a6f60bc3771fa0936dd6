<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur Dynamique de Pr√©diction Stochastique Avanc√©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Setup */
        :root {
            --primary-color: #5B21B6; /* Violet-700 */
            --secondary-color: #059669; /* Green-600 */
            --warning-color: #F59E0B; /* Amber */
            --danger-color: #DC2626; /* Red */
            --bg-color: #f9fafb;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: #1f2937;
        }
        .main-container {
            display: flex;
            min-height: 100vh;
        }
        
        /* Side Panel (Summary/Averages) */
        .side-panel {
            width: 100%;
            max-width: 380px; 
            background-color: white;
            padding: 1.5rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            border-radius: 0.75rem;
            margin: 1rem;
            height: fit-content;
        }
        @media (max-width: 1024px) {
            .main-container { flex-direction: column; }
            .side-panel { max-width: 100%; }
        }

        /* Content Area (Tabs/Tables) */
        .content-area {
            flex-grow: 1;
            padding: 1rem;
        }
        .tab-btn {
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            border-radius: 0.375rem 0.375rem 0 0;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #eef2ff; /* Violet-50 */
            color: #4c1d95; /* Violet-900 */
            margin-right: 0.25rem;
        }
        .tab-btn.active {
            background-color: white;
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
            box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.05);
        }
        .tab-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0 0.75rem 0.75rem 0.75rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }
        .tab-content:not(.active) { display: none; }

        /* Subject Tables (Simplified for Analysis) */
        .subject-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 1.5rem; 
        }
        .subject-table thead th {
            padding: 0.75rem;
            text-align: left;
            background-color: var(--primary-color);
            color: white;
            font-weight: 700;
        }
        .subject-table thead tr:first-child th {
            font-size: 1.125rem;
            text-align: center;
        }
        .subject-table tbody tr:nth-child(even) { background-color: #f3f4f6; }
        .subject-table td {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .grade-percentage {
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Analysis Specifics */
        .subject-analysis {
            background-color: #f5f3ff; /* Purple-50 */
            border: 1px solid #e9d5ff; /* Purple-200 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: -1rem; 
            margin-bottom: 1.5rem;
        }
        .analysis-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }
        .badge-green { background-color: #D1FAE5; color: #065F46; } 
        .badge-yellow { background-color: #FEF3C7; color: #92400E; } 
        .badge-red { background-color: #FEE2E2; color: #991B1B; } 
        .badge-violet { background-color: #E9D5FF; color: #5B21B6; }
        .badge-blue { background-color: #DBEAFE; color: #1E40AF; }

        /* Prediction Cards */
        .prediction-card {
            background-color: #f7f7f7;
            padding: 1rem;
            border-radius: 0.5rem;
            border-left: 4px solid;
            margin-bottom: 1rem;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .card-green { border-left-color: var(--secondary-color); }
        .card-violet { border-left-color: var(--primary-color); }
        .card-yellow { border-left-color: var(--warning-color); }
        .card-red { border-left-color: var(--danger-color); }
        .card-score {
            font-size: 1.875rem; 
            font-weight: 800;
            margin-top: 0.25rem;
        }

        /* Probability Table */
        .probability-table th, .probability-table td {
            padding: 0.5rem;
            text-align: center;
            border: 1px solid #e5e7eb;
        }
        .prob-high { background-color: #D1FAE5; color: #065F46; font-weight: 700;}
        .prob-medium { background-color: #FEF3C7; color: #92400E; }
        .prob-low { background-color: #FEE2E2; color: #991B1B; }
        
        /* Modal - Simplified */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s ease-out;
            opacity: 0;
            pointer-events: none;
        }
        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 500px;
        }

        /* Scorecard style update */
        .score-card {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #f3f4f6;
            transition: all 0.15s;
        }
        .score-card strong {
            font-size: 1.5rem;
        }
        .score-icon {
            font-size: 1.5rem;
            margin-right: 1rem;
        }
        .effort-needed {
            font-size: 1.25rem;
            font-weight: 700;
        }

    </style>
</head>
<body>

    <div class="main-container">

        <!-- Sidebar - R√©sum√© des notes -->
        <div class="side-panel lg:sticky lg:top-4">
            <h2 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2">Moteur Stochastique Pr√©dictif</h2>

            <div class="bg-violet-100 p-4 rounded-lg mb-4 border-l-4 border-violet-600">
                <p class="text-sm font-medium text-gray-700">Pr√©diction Globale Stochastique (Tendance MC)</p>
                <strong id="moyenne-prediction" class="text-4xl font-extrabold text-violet-700">--</strong>
            </div>
            
            <h3 class="text-lg font-semibold mt-6 mb-3 text-gray-800 border-t pt-3">Indices de Risque Dynamique</h3>
            <div id="deep-analysis-scorecard" class="space-y-3 mb-6">
                <!-- Consistency/Effort -->
                <div class="score-card score-high" id="consistency-score">
                    <span class="score-icon text-gray-600">üéØ</span>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Indice de Consistance/Volatilit√© (100 = Parfait)</p>
                        <strong class="text-xl text-gray-800">--</strong>
                    </div>
                </div>
                <!-- Burnout -->
                <div class="score-card score-low" id="burnout-risk-score">
                    <span class="score-icon text-red-600">üî•</span>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Score de Risque de Burnout (100 = Risque Maximal)</p>
                        <strong class="text-xl text-red-600">--</strong>
                    </div>
                </div>
            </div>

            <h3 class="text-lg font-semibold mt-4 mb-2 text-gray-700 border-t pt-3">Moyennes par Mati√®re (<span id="active-etape-name">1</span>)</h3>
            <ul id="subject-averages-list" class="space-y-2 text-base">
                <!-- Subject Averages will be rendered here -->
            </ul>

            <h3 class="text-lg font-semibold mt-4 mb-2 text-gray-700 border-t pt-3">Param√®tres Actuels</h3>
            <div class="space-y-3 mb-6 text-sm">
                <div>
                    <label for="niveau-secondaire" class="block text-sm font-medium text-gray-700">Niveau Secondaire</label>
                    <select id="niveau-secondaire" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm py-2 px-3 focus:ring-primary-500 focus:border-primary-500">
                        <option value="">S√©lectionner</option>
                        <option value="sec4">Secondaire 4</option>
                        <option value="sec5">Secondaire 5</option>
                    </select>
                </div>
                <div>
                    <label for="unites-mode" class="block text-sm font-medium text-gray-700">Mode Unit√©s (Pond√©ration)</label>
                    <div class="flex space-x-2">
                        <select id="unites-mode" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm py-2 px-3 focus:ring-primary-500 focus:border-primary-500">
                            <option value="defaut">D√©faut (Officiel)</option>
                            <option value="sans">Sans Unit√©s (Moy. Simple)</option>
                            <option value="perso">Personnalis√©</option>
                        </select>
                        <button id="unites-btn" class="bg-gray-200 text-gray-600 rounded-md px-3 hover:bg-gray-300 transition duration-150 text-sm">√âditer</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content - Tabs & Tables -->
        <div class="content-area">
            <h1 class="text-3xl font-bold mb-4 text-gray-800">D√©tails de Performance & Pr√©dictions</h1>

            <!-- Tabs -->
            <div class="flex border-b border-gray-200 mb-4">
                <button class="tab-btn active" data-tab="etape1">√âtape 1 - Analyse</button>
                <button class="tab-btn" data-tab="etape2">√âtape 2 - Analyse</button>
                <button class="tab-btn" data-tab="etape3">√âtape 3 - Projection</button>
                <button class="tab-btn" data-tab="simulation">Monte Carlo & Probabilit√©s</button>
            </div>

            <!-- Tab Contents -->
            <div id="tab-contents">
                <div id="etape1" class="tab-content active">
                    <!-- Data for Etape 1 will be rendered here -->
                </div>
                <div id="etape2" class="tab-content">
                    <!-- Data for Etape 2 will be rendered here -->
                </div>
                <div id="etape3" class="tab-content">
                    <!-- Data for Etape 3 will be rendered here -->
                </div>

                <!-- Monte Carlo Simulation Tab -->
                <div id="simulation" class="tab-content">
                    <h2 class="text-2xl font-bold mb-4 text-primary-color">Analyse Pr√©dictive Stochastique (10,000 Sc√©narios)</h2>
                    <p class="text-gray-600 mb-6 border-b pb-4">
                        *L'algorithme utilise le **Facteur Sigma Pond√©r√© (FSP)** pour des simulations stochastiques ajust√©es √† la volatilit√© personnelle de l'√©l√®ve.*
                    </p>

                    <!-- Global Predictions (Confidence Intervals) -->
                    <h3 class="text-xl font-semibold mb-3 mt-4 text-gray-700">Pr√©dictions de Moyenne Finale Globale (Intervalles de Confiance)</h3>
                    <div id="global-predictions" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-4">
                        <!-- Predictions will be rendered here -->
                    </div>

                    <!-- Effort/Volatility Mismatch Analysis -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Analyse de D√©s√©quilibre Volatilit√© / Effort (Mismatch)</h3>
                    <div id="mismatch-analysis" class="space-y-4">
                        <!-- Mismatch analysis will be rendered here -->
                    </div>

                    <!-- Probability Analysis -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Analyse de Chemin : Moyenne Requise √† l'√âtape 3</h3>
                    <p class="text-sm text-gray-600 mb-4">Moyenne exacte que vous devez obtenir √† l'√âtape 3 pour atteindre chaque objectif global, avec la probabilit√© actuelle.</p>
                    <table class="probability-table w-full rounded-lg overflow-hidden">
                        <thead>
                            <tr class="bg-gray-100">
                                <th>Objectif Global (%)</th>
                                <th>Moyenne Requise E3 (%)</th>
                                <th>Probabilit√© (%)</th>
                                <th>Analyse du Risque</th>
                            </tr>
                        </thead>
                        <tbody id="probability-table-body">
                            <!-- Probabilities will be rendered here -->
                        </tbody>
                    </table>

                     <!-- Subject Predictions (Detailed) -->
                    <h3 class="text-xl font-semibold mb-3 mt-8 text-gray-700 border-t pt-4">Pr√©dictions Tendancielles D√©taill√©es par Mati√®re</h3>
                    <p class="text-sm text-gray-600 mb-4">Pr√©diction de note finale (E1+E2+E3) si la performance et le MPP actuels sont maintenus dans cette seule mati√®re. Bas√© sur les notes d√©j√† obtenues.</p>
                    <div id="subject-predictions-list" class="space-y-3">
                        <!-- Subject predictions will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Unit Customization -->
    <div id="unites-modal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4">Unit√©s par Mati√®re</h3>
            <p class="text-sm text-gray-500 mb-4">Ajustez les unit√©s pour chaque mati√®re si le mode 'Personnalis√©' est s√©lectionn√©.</p>
            <div id="unites-list" class="max-h-80 overflow-y-auto border p-3 rounded-md space-y-2">
                <!-- Units will be populated here -->
            </div>
            <div class="mt-6 flex justify-end">
                <button id="close-unites-modal" class="bg-primary-color text-white px-4 py-2 rounded-md hover:bg-violet-700 transition">Fermer & Appliquer</button>
            </div>
        </div>
    </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {

    // --- CONSTANTS AND STATE ---
    const gradeMap = { 'A+': 100, 'A': 95, 'A-': 90, 'B+': 85, 'B': 80, 'B-': 75, 'C+': 70, 'C': 65, 'C-': 60, 'D+': 55, 'D': 50, 'E': 45 };
    const defaultUnits = {
        sec4: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'FRA': 6, 'ELA': 4, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 6, 'ST': 4, 'STE': 4, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'ENT': 2, 'INF': 2, 'PSY': 2, 'SN': 6 },
        sec5: { 'ART': 2, 'MUS': 2, 'DRM': 2, 'CAT': 4, 'FRA': 6, 'ELA': 6, 'EESL': 6, 'ESL': 4, 'MAT': 6, 'CST': 4, 'MED': 4, 'PSY': 4, 'ENT': 4, 'FIN': 4, 'CHI': 4, 'PHY': 4, 'MON': 2, 'HQC': 4, 'CCQ': 2, 'EPS': 2, 'SN': 6 }
    };
    const subjectList = { 'ART': "Arts Plastiques", 'MUS': "Musique", 'DRM': "Art Dramatique", 'CAT': "Conception et Application Technologique", 'FRA': "Fran√ßais", 'ELA': "English Language Arts", 'EESL': "Anglais enrichi", 'ESL': "Anglais langue seconde", 'SN': "Math SN", 'CST': "Math CST", 'ST': "Science et Technologie", 'STE': "Science et Tech. Env.", 'HQC': "Histoire", 'CCQ': "Culture et Citoyennet√©", 'EPS': "√âducation Physique", 'CHI': "Chimie", 'PHY': "Physique", 'MON': "Monde Contemporain", 'MED': "M√©dia", 'ENT': "Entrepreneuriat", 'INF': "Informatique", 'PSY': "Psychologie", 'FIN': "√âducation Financi√®re" };
    
    // Weights for overall global calculation
    const TERM_WEIGHTS = { etape1: 0.20, etape2: 0.20, etape3: 0.60 };

    let mbsData = {};
    let activeTab = 'etape1';
    let cachedAnalysis = null;
    const NUM_MONTE_CARLO_RUNS = 10000; 
    const KNOWN_ETAPE_KEYS = ['etape1', 'etape2']; // Only these are considered 'known' data

    // --- INITIALIZATION ---
    function init() {
        mbsData = JSON.parse(localStorage.getItem('mbsData')) || { 
            valid: true, nom: '√âtudiant', settings: { niveau: 'sec5', unitesMode: 'defaut' } 
        };

        if (!mbsData.valid || !mbsData.nom) {
            document.querySelector('.main-container').innerHTML = `<p style="text-align:center; width:100%; padding: 4rem;">Donn√©es non charg√©es. Veuillez vous assurer que les donn√©es sont enregistr√©es sous 'mbsData' dans le Local Storage.</p>`;
            return;
        }

        loadSettings();
        calculateAndCacheAnalysis();
        renderAll();
        setupEventListeners();
    }

    // --- DATA & SETTINGS MANAGEMENT ---
    function loadSettings() {
        const settings = mbsData.settings || {};
        document.getElementById('niveau-secondaire').value = settings.niveau || '';
        document.getElementById('unites-mode').value = settings.unitesMode || 'defaut';
    }

    function saveSettings() {
        mbsData.settings = mbsData.settings || {};
        mbsData.settings.niveau = document.getElementById('niveau-secondaire').value;
        mbsData.settings.unitesMode = document.getElementById('unites-mode').value;
        mbsData.settings.customUnites = mbsData.settings.customUnites || {};
        
        localStorage.setItem('mbsData', JSON.stringify(mbsData));
        calculateAndCacheAnalysis();
        renderAll();
    }
    
    function saveCustomUnits() {
        const unitesModeEl = document.getElementById('unites-mode');
        if (unitesModeEl.value !== 'perso') return;

        let customUnites = {};
        document.querySelectorAll('.unite-item input').forEach(input => {
            customUnites[input.dataset.code] = parseFloat(input.value) || 1;
        });
        
        mbsData.settings = mbsData.settings || {};
        mbsData.settings.customUnites = customUnites;
        saveSettings();
    }

    // --- RENDERING FUNCTIONS ---
    function renderAll() {
        renderTermTables();
        const analysis = cachedAnalysis;
        renderSidePanel(analysis);
        renderDeepAnalysis(analysis);
        renderMonteCarlo(analysis);
        renderMismatchAnalysis(analysis);
    }

    function renderTermTables() {
        ['etape1', 'etape2', 'etape3'].forEach(key => {
            const container = document.getElementById(key);
            if (container) renderTermData(mbsData[key], container, key, cachedAnalysis);
        });
    }

    function renderTermData(termData, container, etapeKey, analysis) {
        if (!container) return; 

        const allSubjectsInTerm = Object.keys(analysis.subjectStats).filter(code => analysis.subjectStats[code]?.[etapeKey]);

        if (allSubjectsInTerm.length === 0) {
            container.innerHTML = `<p class="no-data text-gray-500">Aucune mati√®re avec donn√©es dans cette √©tape.</p>`;
            return;
        }

        container.innerHTML = '';
        allSubjectsInTerm.forEach(codePrefix => {
            const subject = mbsData[etapeKey].find(s => s.code.startsWith(codePrefix));
            const subjStats = analysis.subjectStats[codePrefix]?.[etapeKey];
            const subjPrediction = analysis.predictions.subjects[codePrefix];

            if (subject && subjStats && subjPrediction) {
                container.appendChild(renderSubjectTable(subject, etapeKey, subjStats, analysis));
                container.appendChild(renderSubjectAnalysis(codePrefix, etapeKey, analysis));
            }
        });
    }

    function renderSubjectTable(subject, etapeKey, subjStats, analysis) {
        const table = document.createElement('table');
        table.className = 'subject-table';
        const codePrefix = subject.code.substring(0, 3);
        const subjectName = subjectList[codePrefix] || subject.name;
        
        // Count steps taken
        const numAssignments = subjStats.allGrades.length;
        
        table.innerHTML = `
            <thead>
                <tr><th colspan="3">${codePrefix} - ${subjectName}</th></tr>
                <tr>
                    <th>Comp√©tence</th>
                    <th>Moyenne Actuelle</th>
                    <th>Pas d'Analyse (Notes Compt√©es)</th>
                </tr>
            </thead>
            <tbody></tbody>`;
        const tbody = table.querySelector('tbody');

        subjStats.competencyAverages.forEach((comp, compIndex) => {
            const compAvg = comp.avg;

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${subject.competencies[compIndex].name}</td>
                <td>${compAvg !== null ? `<span class="grade-percentage">${compAvg.toFixed(2)}%</span>` : '<span class="no-data">N/D</span>'}</td>
                <td>${comp.numAssignments}</td>
            `;
            if (tbody) tbody.appendChild(row);
        });
        
        // Summary Row
        const summaryRow = document.createElement('tr');
        summaryRow.className = 'bg-gray-100 font-semibold';
        summaryRow.innerHTML = `
            <td>TOTAL/GLOBAL</td>
            <td>${analysis.subjectAverages[etapeKey]?.[codePrefix]?.average !== null ? `<span class="grade-percentage text-lg">${analysis.subjectAverages[etapeKey]?.[codePrefix]?.average.toFixed(2)}%</span>` : '<span class="no-data text-lg">N/D</span>'}</td>
            <td>${numAssignments}</td>
        `;
        if (tbody) tbody.appendChild(summaryRow);

        return table;
    }

    function renderSubjectAnalysis(subjectCode, etapeKey, analysis) {
        const analysisDiv = document.createElement('div');
        analysisDiv.className = 'subject-analysis';
        
        const subjAvg = analysis.subjectAverages[etapeKey]?.[subjectCode]?.average;
        const subjOverallStats = analysis.subjectOverallStats[subjectCode];
        const trend = analysis.subjectTrends?.[subjectCode];
        const prediction = analysis.predictions.subjects[subjectCode];

        if (subjAvg === null || subjAvg === undefined || !prediction) {
            analysisDiv.innerHTML = `<p class="text-sm text-gray-500">Aucune donn√©e pour l'analyse de ${subjectList[subjectCode]}.</p>`;
            return analysisDiv;
        }

        // 1. Overall Consistency Badge
        let overallConsistency = subjOverallStats?.overallConsistency || 0;
        let consistencyBadge = { label: 'Volatilit√© Max', class: 'badge-red', icon: '‚ùå' };
        if (overallConsistency >= 90) consistencyBadge = { label: 'Tr√®s Stable', class: 'badge-green', icon: '‚úÖ' };
        else if (overallConsistency >= 70) consistencyBadge = { label: 'Stable', class: 'badge-yellow', icon: '‚ö†Ô∏è' };
        
        // 2. Volatility (StdDev) Badge (Using FSP)
        const fsp = prediction.fsp;
        let volatilityBadge = { label: `FSP: ${fsp.toFixed(1)}`, class: 'badge-violet', icon: '‚ôº' };
        if (fsp > 10) volatilityBadge.class = 'badge-red';
        else if (fsp > 5) volatilityBadge.class = 'badge-yellow';
        else volatilityBadge.class = 'badge-green';
        
        // 3. Trend Badge (Only if E2 exists)
        let trendBadge = { label: 'N/A', class: 'badge-violet', icon: ' ' };
        if (trend) {
            const diff = trend.diff;
            if (diff > 2) trendBadge = { label: `Forte Hausse (+${diff.toFixed(1)}%)`, class: 'badge-green', icon: '‚¨ÜÔ∏è' };
            else if (diff < -2) trendBadge = { label: `Baisse Importante (${diff.toFixed(1)}%)`, class: 'badge-red', icon: '‚¨áÔ∏è' };
            else trendBadge = { label: 'Stable', class: 'badge-yellow', icon: '‚ÜîÔ∏è' };
        }

        // 4. MPP Badge
        const mpp = prediction.mpp;
        let mppBadge = { label: `MPP: x${mpp.toFixed(2)}`, class: 'badge-blue', icon: '‚öôÔ∏è' };
        if (mpp > 1.05) mppBadge.class = 'badge-green';
        else if (mpp < 0.95) mppBadge.class = 'badge-red';
        else mppBadge.class = 'badge-yellow';

        // 5. ND - Niveau de Difficult√©
        const nd = prediction.nd;
        let ndBadge = { label: `ND: ${nd.toFixed(0)}%`, class: 'badge-red', icon: '‚ö°' };
        if (nd <= 20) ndBadge = { label: `ND: ${nd.toFixed(0)}% (Tr√®s Faible)`, class: 'badge-green', icon: '‚ú®' };
        else if (nd <= 50) ndBadge = { label: `ND: ${nd.toFixed(0)}% (Mod√©r√©)`, class: 'badge-yellow', icon: 'üí™' };


        analysisDiv.innerHTML = `
            <div class="flex items-center mb-2 flex-wrap gap-2">
                <span class="text-lg font-semibold text-gray-800 mr-4">${subjectList[subjectCode]}</span>
                <span class="analysis-badge ${consistencyBadge.class}">${consistencyBadge.icon} Consistance E/C: ${overallConsistency.toFixed(0)}/100</span>
                <span class="analysis-badge ${volatilityBadge.class}">${volatilityBadge.icon} ${volatilityBadge.label}</span>
                ${trend ? `<span class="analysis-badge ${trendBadge.class}">${trendBadge.icon} Tendance: ${trendBadge.label}</span>` : ''}
                <span class="analysis-badge ${mppBadge.class}">${mppBadge.icon} MPP: x${mpp.toFixed(2)}</span>
                <span class="analysis-badge ${ndBadge.class}">${ndBadge.icon} ${ndBadge.label}</span>
            </div>
            <p class="text-sm text-gray-700 mt-2">MPP (Multiplicateur de Performance Pr√©dite) = Facteur Dynamique ajustant la pr√©diction E3. ND = Niveau de Difficult√© pour atteindre le score P50 de cette mati√®re.</p>
        `;

        return analysisDiv;
    }

    function renderMismatchAnalysis(analysis) {
        const container = document.getElementById('mismatch-analysis');
        if (!container) return;

        let mismatchHtml = '';
        Object.entries(analysis.predictions.subjects).forEach(([code, subjPred]) => {
            const subjName = subjectList[code] || code;
            const consistency = subjPred.consistency;
            const fsp = subjPred.fsp;
            const nd = subjPred.nd;
            
            // Mismatch Score: High volatility (high fsp) + low consistency (low score) = high mismatch
            const mismatch = fsp * (100 - consistency) / 10;
            
            let color = 'border-blue-500';
            let summary = '√âquilibre correct. Faible FSP et bonne consistance.';

            if (mismatch > 40) {
                color = 'border-red-500';
                summary = '‚ùå **Mismatch Critique**. Volatilit√© extr√™me par rapport √† l\'effort. Le FSP est tr√®s √©lev√©, le risque est maximum.';
            } else if (mismatch > 20) {
                color = 'border-yellow-500';
                summary = '‚ö†Ô∏è **Mismatch Mod√©r√©**. Volatilit√© et consistance sous surveillance. Mati√®re √† risque d\'impr√©vu.';
            } else if (mismatch < 5) {
                color = 'border-green-500';
                summary = '‚úÖ **Excellent Alignement**. Faible volatilit√© et haute consistance. Stabilit√© assur√©e.';
            }

            mismatchHtml += `
                <div class="p-3 rounded-lg border-l-4 ${color} bg-white shadow-sm">
                    <div class="flex justify-between items-center text-gray-800">
                        <strong class="text-lg">${subjName}</strong>
                        <span class="text-sm font-semibold">Score Mismatch: ${mismatch.toFixed(1)}</span>
                    </div>
                    <p class="text-sm text-gray-600 mt-1">${summary}</p>
                    <p class="text-xs text-gray-500 mt-1">Consistance: ${consistency.toFixed(0)}/100 | FSP: ${fsp.toFixed(1)} | ND: ${nd.toFixed(0)}%</p>
                </div>
            `;
        });

        container.innerHTML = mismatchHtml;
    }


    function renderSidePanel(analysis) {
        const formatAvg = (avg) => avg !== null ? `<span class="grade-percentage">${avg.toFixed(2)}%</span>` : '--';
        
        // Prediction (MC Trend) in the sidebar
        const mcTrend = analysis.predictions.global?.trend;
        document.getElementById('moyenne-prediction').innerHTML = formatAvg(mcTrend);
        
        document.getElementById('active-etape-name').textContent = activeTab.replace('etape', '');
        
        const subjectListEl = document.getElementById('subject-averages-list');
        subjectListEl.innerHTML = '';
        const activeTermSubjects = analysis.subjectAverages[activeTab];
        
        if (activeTermSubjects && Object.keys(activeTermSubjects).length > 0) {
            const listItems = Object.entries(activeTermSubjects)
                .filter(([code, subj]) => subj.average !== null)
                .map(([code, subj]) => {
                    return `<li class="flex justify-between"><span>${subj.name}</span><strong>${formatAvg(subj.average)}</strong></li>`;
                })
                .join('');
            
            subjectListEl.innerHTML = listItems || '<li class="no-data text-gray-500">Aucune moyenne calcul√©e pour cette √©tape</li>';
        } else {
            subjectListEl.innerHTML = '<li class="no-data text-gray-500">Aucune mati√®re pour cette √©tape</li>';
        }
    }

    function renderDeepAnalysis(analysis) {
        const { globalConsistencyScore, burnoutRiskScore } = analysis;
        
        // 1. Consistency
        const consistencyEl = document.getElementById('consistency-score');
        if (consistencyEl) {
            consistencyEl.className = 'score-card';
            consistencyEl.querySelector('strong').textContent = globalConsistencyScore.toFixed(0) + ' / 100';
            if (globalConsistencyScore < 70) consistencyEl.classList.add('card-red');
            else if (globalConsistencyScore < 90) consistencyEl.classList.add('card-violet');
            else consistencyEl.classList.add('card-green');
        }

        // 2. Burnout Risk (High score = high risk)
        const riskEl = document.getElementById('burnout-risk-score');
        if (riskEl) {
            riskEl.className = 'score-card';
            riskEl.querySelector('strong').textContent = burnoutRiskScore.toFixed(0) + ' / 100';
            if (burnoutRiskScore > 70) riskEl.classList.add('card-red');
            else if (burnoutRiskScore > 40) riskEl.classList.add('card-yellow');
            else riskEl.classList.add('card-green');
            
            riskEl.querySelector('p').textContent = `Score de Risque de Burnout (100 = Risque Maximal) - ${getBurnoutLabel(burnoutRiskScore)}`;
        }
    }

    function getBurnoutLabel(score) {
        if (score > 85) return 'Urgence: Surcharge et Volatilit√© Extr√™mes.';
        if (score > 70) return 'Tr√®s √âlev√©: Risque majeur de fatigue et notes impr√©visibles.';
        if (score > 50) return '√âlev√©: Forte charge ou Consistance √† surveiller.';
        if (score > 30) return 'Mod√©r√©: Charge g√©rable mais l√©g√®re baisse de performance.';
        return 'Faible: Stabilit√© et Effort bien g√©r√©s.';
    }

    function renderMonteCarlo(analysis) {
        const { predictions } = analysis;
        const globalPredEl = document.getElementById('global-predictions');
        const probTableEl = document.getElementById('probability-table-body');
        const subjPredEl = document.getElementById('subject-predictions-list');
        
        if (!globalPredEl || !probTableEl || !subjPredEl) return;

        // --- 1. Global Predictions (Confidence Intervals) ---
        const predictionScenarios = [
            { name: "1. Tendance Pessimiste (P5)", key: 'p5', desc: '95% de chance d\'obtenir au moins ce score. N√©cessite un effort MOD√âR√â/CIBL√â.', class: 'card-red', effort: 'Mod√©r√©/Cibl√©' },
            { name: "2. Quartile Inf√©rieur (P25)", key: 'p25', desc: 'Limite basse du 25% des simulations.', class: 'card-yellow', effort: 'Mod√©r√©/Soutenu' },
            { name: "3. M√©dian (P50) - Le Plus Probable", key: 'p50', desc: 'Score m√©dian. 50% de chance d\'√™tre au-dessus. TENDANCE ACTUELLE.', class: 'card-violet', effort: 'Maintenir l\'√âquilibre' },
            { name: "4. Quartile Sup√©rieur (P75)", key: 'p75', desc: 'Limite haute du 25% des simulations. N√©cessite un effort SOUTENU.', class: 'card-violet', effort: 'Soutenu' },
            { name: "5. Tendance Optimiste (P95)", key: 'p95', desc: '5% de chance d\'√™tre meilleur que ce score. N√©cessite un effort INT√âGRAL/MAXIMAL.', class: 'card-green', effort: 'Maximal' },
        ];
        
        globalPredEl.innerHTML = predictionScenarios.map(scenario => {
            const value = predictions.global?.[scenario.key];
            const display = value !== null ? (value > 100 ? '>100%' : `${value.toFixed(2)}%`) : '--';
            const colorClass = scenario.class;
            
            return `
                <div class="prediction-card ${colorClass}">
                    <p class="font-bold text-gray-700">${scenario.name}</p>
                    <p class="text-sm text-gray-500">${scenario.desc}</p>
                    <div class="flex justify-between items-center mt-2">
                        <div class="card-score text-gray-900">${display}</div>
                        <span class="effort-needed text-sm text-gray-600">${scenario.effort}</span>
                    </div>
                </div>
            `;
        }).join('');


        // --- 2. Probability Analysis & Required Average E3 ---
        const targets = [95, 92, 90, 88, 85, 80, 75, 70, 60];
        probTableEl.innerHTML = targets.map(target => {
            const { requiredAvg, prob } = predictions.probabilityAnalysis[target];
            
            let probClass = 'prob-low';
            let effort = 'Effort Extr√™me (Difficile)';

            if (prob >= 90) { probClass = 'prob-high'; effort = 'Maintenir Consistance (Tr√®s Faisable)'; }
            else if (prob >= 70) { probClass = 'prob-medium'; effort = 'Effort Mod√©r√©/Cibl√© (Faisable)'; }
            else if (prob >= 40) { probClass = 'prob-low'; effort = 'Effort Int√©gral (Pari)'; }

            let requiredAvgDisplay = requiredAvg !== null ? (requiredAvg > 100 ? 'IMPOSSIBLE (100+)' : `${requiredAvg.toFixed(2)}%`) : '--';
            if (requiredAvg !== null && requiredAvg < 60) requiredAvgDisplay = `<span class="text-green-600">FAIBLE (${requiredAvg.toFixed(2)}%)</span>`;
            else if (requiredAvg !== null && requiredAvg > 100) requiredAvgDisplay = `<span class="text-red-600">IMPOSSIBLE (100+%)</span>`;
            
            return `
                <tr class="${probClass}">
                    <td>${target}%</td>
                    <td>${requiredAvgDisplay}</td>
                    <td>${prob.toFixed(0)}%</td>
                    <td>${effort}</td>
                </tr>
            `;
        }).join('');
        
        // --- 3. Subject Predictions ---
        subjPredEl.innerHTML = Object.entries(predictions.subjects).map(([code, subjPred]) => {
            const prediction = subjPred.predictionFinal;
            
            const cardClass = prediction >= 90 ? 'card-green' : (prediction >= 80 ? 'card-violet' : 'card-red');

            return `
                <div class="prediction-card ${cardClass}">
                    <div class="flex justify-between items-center">
                        <p class="font-bold text-lg text-gray-800">${subjectList[code] || code}</p>
                        <div class="text-sm text-gray-500">
                            MPP: x${subjPred.mpp.toFixed(2)} | ND: ${subjPred.nd.toFixed(0)}%
                        </div>
                    </div>
                    <p class="text-sm text-gray-500">Pr√©diction Stochastique Finale (Bas√©e sur l'existant)</p>
                    <div class="card-score text-gray-900">${prediction !== null ? prediction.toFixed(2) + '%' : '--'}</div>
                </div>
            `;
        }).join('');
    }

    // --- CALCULATION LOGIC ---
    function getNumericGrade(result) {
        if (!result) return null;
        const trimmed = result.trim();
        if (gradeMap[trimmed]) return gradeMap[trimmed];
        
        const percentageMatch = trimmed.match(/(\d+[,.]?\d*)\s*%/);
        if (percentageMatch) return parseFloat(percentageMatch[1].replace(',', '.'));

        const scoreMatch = trimmed.match(/(\d+[,.]?\d*)\s*\/\s*(\d+[,.]?\d*)/);
        if (scoreMatch) {
            const score = parseFloat(scoreMatch[1].replace(',', '.'));
            const max = parseFloat(scoreMatch[2].replace(',', '.'));
            return (max > 0) ? (score / max) * 100 : null;
        }
        return null;
    }
    
    function getUnits() {
        const { niveau, unitesMode, customUnites } = mbsData.settings || {};
        if (unitesMode === 'sans') return new Proxy({}, { get: () => 1 });
        if (unitesMode === 'perso') return customUnites || {};
        return (niveau && defaultUnits[niveau]) ? defaultUnits[niveau] : {};
    }
    
    function calculateAndCacheAnalysis() {
        cachedAnalysis = calculateAllAnalysis();
    }

    function calculateSubjectAverageAndStats(subject, etapeKey) {
        let totalWeightedGrade = 0;
        let totalCompetencyWeight = 0;
        let allGrades = [];
        let competencyAverages = [];

        subject.competencies.forEach((comp, compIndex) => {
            const compWeightMatch = comp.name.match(/\((\d+)%\)/);
            const compWeight = compWeightMatch ? parseFloat(compWeightMatch[1]) : 0;
            if (compWeight === 0) return;

            let compGrades = [];
            let totalAssignmentGrade = 0;
            let totalAssignmentWeight = 0;
            let numAssignments = 0;

            comp.assignments.forEach(assign => {
                const grade = getNumericGrade(assign.result);
                let weight = parseFloat(assign.pond || 0);

                if (grade !== null && !isNaN(grade) && !isNaN(weight) && weight > 0) {
                    allGrades.push(grade);
                    compGrades.push(grade);
                    totalAssignmentGrade += grade * weight;
                    totalAssignmentWeight += weight;
                    numAssignments++;
                }
            });

            let compAvg = null;
            if (totalAssignmentWeight > 0) {
                compAvg = totalAssignmentGrade / totalAssignmentWeight;
                totalWeightedGrade += compAvg * (compWeight / 100);
                totalCompetencyWeight += (compWeight / 100);
            }

            competencyAverages.push({ avg: compAvg, numAssignments });
        });

        const subjectAverage = totalCompetencyWeight > 0 ? (totalWeightedGrade / totalCompetencyWeight) : null;
        
        // Stats are calculated across ALL grades obtained in this single term
        const overallConsistency = allGrades.length >= 2 ? calculateConsistencyScore(allGrades) : 100;
        const stdDev = allGrades.length >= 2 ? calculateStdDev(allGrades) : 0;
        
        return { subjectAverage, allGrades, overallConsistency, stdDev, competencyAverages };
    }

    function calculateConsistencyScore(grades) {
        const stdDev = calculateStdDev(grades);
        // Consistency is inversely proportional to volatility (StdDev * 2 is a heuristic penalty)
        return Math.max(0, 100 - (stdDev * 2));
    }
    
    function calculateStdDev(grades) {
        if (grades.length < 2) return 0;
        const mean = grades.reduce((a, b) => a + b) / grades.length;
        const variance = grades.reduce((sum, grade) => sum + Math.pow(grade - mean, 2), 0) / grades.length;
        return Math.sqrt(variance);
    }

    function calculateWeightedFinalAvg(etape1Avg, etape2Avg, etape3Avg) {
        let weightedSum = 0;
        let totalWeight = 0;
        
        if (etape1Avg !== null) { weightedSum += etape1Avg * TERM_WEIGHTS.etape1; totalWeight += TERM_WEIGHTS.etape1; }
        if (etape2Avg !== null) { weightedSum += etape2Avg * TERM_WEIGHTS.etape2; totalWeight += TERM_WEIGHTS.etape2; }
        if (etape3Avg !== null) { weightedSum += etape3Avg * TERM_WEIGHTS.etape3; totalWeight += TERM_WEIGHTS.etape3; }
        
        return totalWeight > 0 ? weightedSum / totalWeight : null;
    }
    
    function calculateAllAnalysis() {
        const units = getUnits();
        const niveau = mbsData.settings?.niveau;
        let allTermAverages = { etape1: null, etape2: null, etape3: null };
        let allSubjectAverages = {};
        let allSubjectStats = {}; 
        let allSubjectOverallStats = {}; 
        let allGradesGlobal = [];
        
        // 1. Calculate Averages and Stats per Subject/Etape
        KNOWN_ETAPE_KEYS.forEach(etape => {
            if (!mbsData[etape]) return;
            allSubjectAverages[etape] = {};

            mbsData[etape].forEach((subject) => {
                const codePrefix = subject.code.substring(0, 3);
                
                const { subjectAverage, allGrades, overallConsistency, stdDev, competencyAverages } = 
                    calculateSubjectAverageAndStats(subject, etape);

                allGradesGlobal.push(...allGrades);
                
                allSubjectAverages[etape][codePrefix] = { name: subjectList[codePrefix] || subject.name, average: subjectAverage };
                
                allSubjectStats[codePrefix] = allSubjectStats[codePrefix] || {};
                allSubjectStats[codePrefix][etape] = { overallConsistency, stdDev, competencyAverages, allGrades, numGrades: allGrades.length };
            });
        });

        // 1.5 Calculate Overall Subject Stats (across all known terms)
        Object.keys(allSubjectStats).forEach(code => {
            let grades = [];
            let allConsistencies = [];
            let totalNumGrades = 0;

            KNOWN_ETAPE_KEYS.forEach(etape => {
                if (allSubjectStats[code][etape]) {
                    grades.push(...allSubjectStats[code][etape].allGrades);
                    allConsistencies.push(allSubjectStats[code][etape].overallConsistency);
                    totalNumGrades += allSubjectStats[code][etape].numGrades;
                }
            });
            const overallStdDev = calculateStdDev(grades);
            const overallConsistency = allConsistencies.length > 0 ? allConsistencies.reduce((a, b) => a + b) / allConsistencies.length : 100;
            
            allSubjectOverallStats[code] = { allGrades: grades, stdDev: overallStdDev, overallConsistency, numGrades: totalNumGrades };
        });


        // 2. Calculate Global Average (Only Known Terms)
        let globalWeightedSum = 0;
        let totalKnownWeight = 0;
        
        KNOWN_ETAPE_KEYS.forEach(etape => {
            let termWeightedSum = 0;
            let termUnitSum = 0;
            
            Object.keys(allSubjectAverages[etape] || {}).forEach(codePrefix => {
                const avg = allSubjectAverages[etape][codePrefix].average;
                if (avg !== null && niveau) {
                    const unit = units[codePrefix] || 2;
                    termWeightedSum += avg * unit;
                    termUnitSum += unit;
                }
            });
            
            allTermAverages[etape] = termUnitSum > 0 ? termWeightedSum / termUnitSum : null;

            if (allTermAverages[etape] !== null) {
                globalWeightedSum += allTermAverages[etape] * TERM_WEIGHTS[etape];
                totalKnownWeight += TERM_WEIGHTS[etape];
            }
        });

        const globalAverageKnown = totalKnownWeight > 0 ? globalWeightedSum / totalKnownWeight : null;

        // 3. Calculate Global Statistics
        let globalStdDev = allGradesGlobal.length >= 2 ? calculateStdDev(allGradesGlobal) : 0;
        let globalConsistencyScore = allGradesGlobal.length >= 2 ? calculateConsistencyScore(allGradesGlobal) : 100;


        // 4. Subject Trends
        let subjectTrends = {};
        Object.keys(allSubjectStats).forEach(code => {
            const avg1 = allSubjectAverages.etape1?.[code]?.average || null;
            const avg2 = allSubjectAverages.etape2?.[code]?.average || null;
            if (avg1 !== null && avg2 !== null) {
                subjectTrends[code] = { diff: avg2 - avg1 }; 
            }
        });
        
        // 5. Burnout Risk
        let burnoutRiskScore = calculateBurnoutRisk(niveau, globalStdDev, allSubjectOverallStats, units);

        // 6. Monte Carlo Predictions
        const predictions = runMonteCarloSimulation(globalAverageKnown, allTermAverages, allSubjectAverages, subjectTrends, allSubjectOverallStats, units);


        return { 
            subjectAverages: allSubjectAverages, 
            termAverages: allTermAverages, 
            globalAverage: globalAverageKnown, 
            globalStdDev, 
            globalConsistencyScore, 
            subjectStats: allSubjectStats,
            subjectOverallStats: allSubjectOverallStats,
            subjectTrends,
            burnoutRiskScore,
            predictions
        };
    }
    
    function calculateBurnoutRisk(niveau, globalStdDev, allSubjectOverallStats, units) {
        if (!niveau) return 0;
        
        // Component 1: Workload (Units) - Max 30 points
        let totalUnits = Object.values(units).reduce((sum, u) => sum + (u || 0), 0);
        let workloadScore = Math.min(30, (totalUnits / 30) * 30); 

        // Component 2: Global Volatility (StdDev) - Max 40 points
        let volatilityScore = Math.min(40, globalStdDev * 2.5); 

        // Component 3: Effort Mismatch (Average of all subject mismatches) - Max 30 points
        let totalMismatch = 0;
        let count = 0;
        Object.values(allSubjectOverallStats).forEach(s => {
            if (s.numGrades > 0) { 
                // We need ND for accurate mismatch, but ND relies on the full MC run. 
                // For a pre-MC risk assessment, we use a proxy for mismatch.
                // Proxy Mismatch = StdDev * (100 - Consistency) / 10
                const proxyMismatch = s.stdDev * (100 - s.overallConsistency) / 10; 
                totalMismatch += proxyMismatch;
                count++; 
            }
        });
        let mismatchScore = count > 0 ? Math.min(30, (totalMismatch / count) * 0.8) : 0; 

        return Math.min(100, workloadScore + volatilityScore + mismatchScore);
    }
    
    // --- MONTE CARLO CORE LOGIC ---
    function runMonteCarloSimulation(globalAverageKnown, termAverages, subjectAverages, subjectTrends, subjectOverallStats, units) {
        const globalPred = { p5: null, p25: null, p50: null, p75: null, p95: null };
        const subjectPreds = {};
        const targets = [95, 92, 90, 88, 85, 80, 75, 70, 60];
        const probabilityAnalysis = {};
        
        const avg1 = termAverages.etape1;
        const avg2 = termAverages.etape2;

        let currentKnownGlobalSum = 0;
        let totalKnownWeight = 0;
        
        if (avg1 !== null) {
            currentKnownGlobalSum += avg1 * TERM_WEIGHTS.etape1;
            totalKnownWeight += TERM_WEIGHTS.etape1;
        }
        if (avg2 !== null) {
            currentKnownGlobalSum += avg2 * TERM_WEIGHTS.etape2;
            totalKnownWeight += TERM_WEIGHTS.etape2;
        }
        
        const totalWeight = TERM_WEIGHTS.etape1 + TERM_WEIGHTS.etape2 + TERM_WEIGHTS.etape3;
        const remainingWeight = totalWeight - totalKnownWeight;

        // If no remaining weight, prediction is the known average
        if (remainingWeight <= 0) {
             globalPred.p5 = globalPred.p25 = globalPred.p50 = globalPred.p75 = globalPred.p95 = globalAverageKnown;
             globalPred.trend = globalAverageKnown;
             targets.forEach(t => {
                probabilityAnalysis[t] = { requiredAvg: null, prob: globalAverageKnown >= t ? 100 : 0 };
             });
             return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
        }
        
        // Identify subjects relevant for E3 prediction (those with units and at least one known term average)
        const relevantSubjects = Object.keys(subjectOverallStats).filter(code => units[code] && subjectOverallStats[code].numGrades > 0);
        
        if (relevantSubjects.length === 0) {
            targets.forEach(t => { probabilityAnalysis[t] = { requiredAvg: 0, prob: 100 }; });
            return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
        }
        
        // --- PRE-CALCULATIONS FOR ACCURACY (FSP & MPP) ---
        relevantSubjects.forEach(code => {
            const subjStats = subjectOverallStats[code];
            const trend = subjectTrends[code];
            const subjAvg1 = subjectAverages.etape1?.[code]?.average || null;
            const subjAvg2 = subjectAverages.etape2?.[code]?.average || null;
            let trendAvg = subjAvg2 !== null ? subjAvg2 : (subjAvg1 !== null ? subjAvg1 : 75); 
            let stdDev = subjStats.stdDev;
            
            // 1. FSP (Facteur Sigma Pond√©r√©) - Adjust based on Consistency and Data Quantity
            const inconsistencyFactor = (100 - subjStats.overallConsistency) / 100;
            let fsp = stdDev * (1 + inconsistencyFactor); 
            
            // FSP Adjustment for Low Data Quantity (less than 5 grades)
            if (subjStats.numGrades < 5) {
                fsp = fsp + (5 - subjStats.numGrades) * 0.5; // Adds up to 2.5 points of StdDev for 0 grades
            } else if (subjStats.numGrades > 15 && fsp > 2) {
                 // Slight reduction if data is abundant and FSP is high
                fsp = fsp * 0.95;
            }
            fsp = Math.max(0.5, fsp); // Minimum FSP to allow simulation randomness

            // 2. ND (Niveau de Difficult√©) - Requires a quick subject-level MC to find P50
            let finalSubjectGradesP50 = [];
            
            for (let i = 0; i < 500; i++) { // Shorter MC run for ND estimation
                const u1 = Math.random();
                const u2 = Math.random();
                let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                let predictedE3Avg = Math.min(100, Math.max(0, trendAvg + z * fsp));
                
                const finalGrade = calculateWeightedFinalAvg(subjAvg1, subjAvg2, predictedE3Avg);
                finalSubjectGradesP50.push(finalGrade);
            }
            finalSubjectGradesP50.sort((a, b) => a - b);
            const subjectP50 = finalSubjectGradesP50[Math.floor(500 * 0.50)] || trendAvg;
            
            // ND Calculation: ND = |P50 - Current Avg| / (Max Possible P50)
            const maxDelta = 100 - trendAvg;
            const requiredDelta = subjectP50 - trendAvg;
            const ndScore = maxDelta > 0 ? (requiredDelta / maxDelta) * 100 : 0;
            let nd = Math.min(100, Math.max(0, ndScore));

            // 3. MPP (Multiplicateur de Performance Pr√©dite) - Adjust based on Trend, Consistency, and ND
            let trendAdjustment = trend?.diff ? Math.min(5, Math.max(-5, trend.diff)) * 0.5 : 0; 
            let consistencyAdjustment = 0;
            if (subjStats.overallConsistency >= 90) consistencyAdjustment = 2.5; 
            else if (subjStats.overallConsistency < 70) consistencyAdjustment = -2.5; 
            
            // ND Adjustment for MPP
            let ndAdjustment = 0;
            if (nd <= 20) ndAdjustment = 1.0; // Small bonus if current success is easy to maintain
            else if (nd >= 80) ndAdjustment = -1.0; // Small penalty if current high score is difficult to maintain

            const mpp = Math.min(1.10, Math.max(0.90, 1 + (trendAdjustment + consistencyAdjustment + ndAdjustment) / 100)); 
            const adjustedMean = trendAvg * mpp;

            // Store interim results
            subjectPreds[code] = { 
                mpp: mpp,
                fsp: fsp,
                consistency: subjStats.overallConsistency,
                adjustedMean: adjustedMean,
                nd: nd,
                predictionFinal: null // To be filled later
            };
        });

        // --- 1. Required Average for Etape 3 (Deterministic) ---
        targets.forEach(target => {
            const requiredAvg = (target * totalWeight - currentKnownGlobalSum) / remainingWeight;
            
            // Simplified probability (based on global average and SD for initial analysis)
            const currentTrendAvg = globalAverageKnown !== null ? globalAverageKnown : 75; 
            const stdDevProxy = Object.values(subjectPreds).length > 0 ? 
                                Object.values(subjectPreds).reduce((sum, s) => sum + s.fsp, 0) / Object.values(subjectPreds).length : 5;
            
            const prob = calculateProbability(currentTrendAvg, stdDevProxy, requiredAvg);

            probabilityAnalysis[target] = { requiredAvg: requiredAvg, prob: prob };
        });


        // --- 2. Monte Carlo Simulation (Stochastic) ---
        let finalGlobalGrades = [];
        
        for (let i = 0; i < NUM_MONTE_CARLO_RUNS; i++) {
            let simRemainingSum = 0;
            let simTotalUnitWeight = 0;
            
            relevantSubjects.forEach(code => {
                const subjPred = subjectPreds[code];
                const unit = units[code] || 2;
                const subjAvg1 = subjectAverages.etape1?.[code]?.average || null;
                const subjAvg2 = subjectAverages.etape2?.[code]?.average || null;
                
                // Re-calculate E3 Prediction using adjusted mean and FSP
                const u1 = Math.random();
                const u2 = Math.random();
                let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                
                // Prediction based on Adjusted Mean (MPP) and FSP (Sigma Pond√©r√©)
                let predictedE3Avg = Math.min(100, Math.max(0, subjPred.adjustedMean + z * subjPred.fsp)); 
                
                simRemainingSum += predictedE3Avg * unit;
                simTotalUnitWeight += unit;

                // Capture subject final grade for subject trend calculation (only once per subject)
                if (i === 0) {
                     const finalGrade = calculateWeightedFinalAvg(subjAvg1, subjAvg2, predictedE3Avg);
                     subjPred.predictionFinal = finalGrade;
                }
            });
            
            const predictedE3AvgGlobal = simTotalUnitWeight > 0 ? simRemainingSum / simTotalUnitWeight : 0;
            const finalGlobalGrade = (currentKnownGlobalSum + predictedE3AvgGlobal * remainingWeight) / totalWeight;
            
            finalGlobalGrades.push(finalGlobalGrade);
        }

        // --- 3. Final Monte Carlo Results (Percentiles) ---
        finalGlobalGrades.sort((a, b) => a - b);

        globalPred.p5 = finalGlobalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.05)] || 0;
        globalPred.p25 = finalGlobalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.25)] || 0;
        globalPred.p50 = finalGlobalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.50)] || 0;
        globalPred.p75 = finalGlobalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.75)] || 0;
        globalPred.p95 = finalGlobalGrades[Math.floor(NUM_MONTE_CARLO_RUNS * 0.95)] || 0;
        globalPred.trend = finalGlobalGrades.reduce((a, b) => a + b) / NUM_MONTE_CARLO_RUNS; // Actual Mean

        // Re-evaluate probability based on MC trend and its own SD
        const mcStdDev = calculateStdDev(finalGlobalGrades);
        targets.forEach(target => {
            const prob = calculateProbability(globalPred.trend, mcStdDev, probabilityAnalysis[target].requiredAvg);
            probabilityAnalysis[target].prob = prob;
        });
        
        // Ensure final subject prediction is set for all relevant subjects (using the trend average from the first simulation pass)
        Object.keys(subjectPreds).forEach(code => {
            if (subjectPreds[code].predictionFinal === null) {
                // If it wasn't set (e.g., if relevantSubjects was empty or an error occurred), default to the trendAvg
                const subjAvg1 = subjectAverages.etape1?.[code]?.average || null;
                const subjAvg2 = subjectAverages.etape2?.[code]?.average || null;
                let trendAvg = subjAvg2 !== null ? subjAvg2 : (subjAvg1 !== null ? subjAvg1 : 75); 
                subjectPreds[code].predictionFinal = trendAvg;
            }
        });


        return { global: globalPred, subjects: subjectPreds, probabilityAnalysis };
    }

    // Approx. Probability based on Z-Score (CDF)
    function calculateProbability(mean, stdDev, requiredTarget) {
        if (mean === null) return 0;
        if (stdDev <= 0.1) return mean >= requiredTarget ? 100 : 0;
        
        if (requiredTarget > 100) return 0;
        
        // If the target is already below the trend mean (P50), the probability must be > 50%
        if (requiredTarget <= mean) {
            // Use a function that converges to 100% as target moves far below the mean
            const z = (mean - requiredTarget) / stdDev;
            return Math.min(100, 50 + 50 * (1 - Math.exp(-z * 0.7))); 
        }

        const z = (requiredTarget - mean) / stdDev;

        // Custom approximation of 1-CDF(z) for a more linear feel at extremes
        if (z < 0.5) {
            return 50 - 50 * z / 2;
        } else if (z < 1.0) {
            return 37.5 - 20 * (z - 0.5);
        } else if (z < 1.5) {
            return 27.5 - 15 * (z - 1.0);
        } else if (z < 2.0) {
            return 20 - 10 * (z - 1.5);
        } else if (z < 2.5) {
            return 15 - 5 * (z - 2.0);
        } else {
            return Math.max(0.1, 12.5 - 5 * (z - 2.5)); // Slow decay to near 0
        }
    }


    // --- EVENT LISTENERS ---
    function setupEventListeners() {
        // Tabs
        document.querySelectorAll('.tab-btn').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelector('.tab-btn.active')?.classList.remove('active');
                tab.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                activeTab = tab.dataset.tab;
                document.getElementById(activeTab)?.classList.add('active');
                
                renderSidePanel(cachedAnalysis);
            });
        });

        // Settings
        document.getElementById('niveau-secondaire')?.addEventListener('change', saveSettings);
        document.getElementById('unites-mode')?.addEventListener('change', () => {
            saveSettings();
            populateUnitesModal();
        });

        // Modals
        const unitesModal = document.getElementById('unites-modal');
        document.getElementById('unites-btn')?.addEventListener('click', () => {
            populateUnitesModal();
            unitesModal?.classList.add('active');
        });
        document.getElementById('close-unites-modal')?.addEventListener('click', () => {
            saveCustomUnits();
            unitesModal?.classList.remove('active');
        });
    }
    
    function populateUnitesModal() {
        const unitesListEl = document.getElementById('unites-list');
        if (!unitesListEl) return;
        
        unitesListEl.innerHTML = '';

        const currentUnits = getUnits();
        const subjectCodes = new Set();

        KNOWN_ETAPE_KEYS.forEach(etapeKey => {
            mbsData[etapeKey]?.forEach(subject => {
                const codePrefix = subject.code.substring(0, 3);
                subjectCodes.add(codePrefix);
            });
        });

        Array.from(subjectCodes).sort().forEach(code => {
            const currentUnitValue = currentUnits[code] || 2; 
            const li = document.createElement('div');
            li.className = 'unite-item flex justify-between items-center border-b border-gray-200 py-2';
            li.innerHTML = `
                <span class="text-gray-700">${subjectList[code] || code} (${code})</span>
                <input type="number" class="w-20 text-right p-1 border rounded-md" value="${currentUnitValue}" min="0" max="10" data-code="${code}" onchange="saveCustomUnits()">
            `;
            unitesListEl.appendChild(li);
        });
        window.saveCustomUnits = saveCustomUnits;
    }

    // --- START THE APP ---
    init();
});
    </script>
</body>
</html>
